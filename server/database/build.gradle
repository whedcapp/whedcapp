/*
  This file is part of Whedcapp - Well-being Health Environment Data Collection App - to collect self-evaluated data for research purpose
  Copyright (C) 2020-2021  Jonas Mellin, Catharina Gillsj√∂

  Whedcapp is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Whedcapp is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with Whedcapp.  If not, see <https://www.gnu.org/licenses/>.
*/

buildscript{
    repositories{
        jcenter()
    }

    dependencies{
        classpath 'mysql:mysql-connector-java:8.0.23'
    }
}


import groovy.transform.AutoClone;
import groovy.swing.SwingBuilder
import org.apache.tools.ant.filters.*
import java.sql.SQLException
import java.util.Optional
import java.util.regex.*
//import org.apache.commons.io.FileNameUtils

// Whedcapp admin user identity
ext.wcau = ''
def getWcau = {
    return ext.wcau
};

@AutoClone
public  class ExtractedSqlStatement {
    private String statement;
    private String type;
    private String id;
    ExtractedSqlStatement() { statement = type = id = null; }
    public String getStatement() {
        if (!isPresent()) {
            throw new IllegalStateException("ExtractedSqlStatement contains nothing");
        }
        return statement;
    }
    public String getType() {
        if (!isPresent()) {
            throw new IllegalStateException("ExtractedSqlStatement contains nothing");
        }
        return type;
    }
    public String getId() {
        if (!isPresent()) {
            throw new IllegalStateException("ExtractedSqlStatement contains nothing");
        }
        return id;
    }
    public void setStatement(String statement) {
        this.statement = statement;
    }
    public void setType(String type) {
        this.type = type;
    }
    public void setId(String id) {
        this.id = id;
    }
    public boolean isPresent() {
        return statement != null;
    }
    public void reset() {
        statement = type = id = null;
    }
    public String toString() {
        return id + "-> <"+statement+">, ["+type+"]";
    }
};

class SqlScriptIterator implements Iterator<ExtractedSqlStatement> {
    public static class SqlPattern {
        private List<String> pattern;
        private boolean hasId;
        private boolean endsWithDelimiter;
        public SqlPattern(List<String> pattern, boolean hasId, boolean endsWithDelimiter) {
            this.pattern = pattern;
            this.hasId = hasId;
            this.endsWithDelimiter = endsWithDelimiter;
        }
        public List<String> getPattern() {
            return pattern;
        }
        public boolean getHasId() {
            return hasId;
        }
        public boolean getEndsWithDelimiter() {
            return endsWithDelimiter;
        }
    };
    private String str;
    private int index = 0;
    private int endIndexLastMatch;
    private ExtractedSqlStatement extractedSqlStatement = new ExtractedSqlStatement();
    private Optional<String> lastResult = Optional.empty();
    private Optional<String> lastType = Optional.empty();

    private Optional<String> lastId = Optional.empty();
    private String delimiter = ";";
    private static idPattern = /^(?i)\s*((`[a-z_][a-z0-9_]*`(.?`[a-z_][a-z0-9_]*`|))|([a-z_][a-z0-9_]*(.?[a-z_][a-z0-9_]*|)))/;
    private static Map<String,Map<String,SqlPattern>> expr2type = [
                                                                   CREATE: new SqlPattern( ["^(?i)\\s*CREATE","^(?i)\\s*(TABLE|PROCEDURE|FUNCTION|VIEW|TRIGGER|INDEX|DATABASE)","^(?i)\\s*(IF\\s+NOT\\s+EXISTS|)"], true, true),
                                                                   DROP: new SqlPattern( ["^(?i)\\s*DROP","^(?i)\\s*(TABLE|PROCEDURE|FUNCTION|VIEW|TRIGGER|INDEX|DATABASE)","^(?i)\\s*(IF\\s+EXISTS|)"], true, true),
                                                                   USE: new SqlPattern( ["^(?i)\\s*USE"], true, true),
                                                                   INSERT: new SqlPattern([/^(?i)\s*INSERT\s+INTO/], true, true),
                                                                   DELIMITER: new SqlPattern( [/^(?i)\s*DELIMITER/], false, false)
                         ];

    private int matchPrequel(List<String> lop,final String str) {
        int tmpStart = 0;
        String tmp = str.substring(tmpStart);
        for (String p: lop) {
            def m = tmp =~ p;
            
            if (!m.find()) {
                return -1;
            }
            tmpStart += m.group().length();
            tmp = str.substring(tmpStart);
                
        }
        return tmpStart;
    }
    private int skipSequenceOfDelimiters(final String str) {
        int baseStart = 0;
        while (true) {
            def tmp = str.substring(baseStart);
            def m = tmp =~ "^\\s*";
            m.find();
            if (m.group().length()>-1) {
                int nextDelimiterIndex = str.indexOf(delimiter,baseStart);
                if (nextDelimiterIndex == baseStart+m.group().length()) {
                    baseStart = nextDelimiterIndex+delimiter.length();
                } else {
                    break;
                }
            } else {
                break;
            }
        }
        println "skipSequenceOfDelimiters baseStart = "+baseStart;
        return baseStart;
    }
    private boolean matchAnyPrequel(final String str,ExtractedSqlStatement extractedSqlStatement) {
        Optional<String> tmpId = Optional.empty();
        int tmpEndIndexLastMatch;
        boolean completed=false;
        def typeString = "";
        int baseStart = skipSequenceOfDelimiters(str);
        // insert nextStart here and skip sequences of delimiters
        for (def e2t: expr2type) {
            tmpEndIndexLastMatch = 0;
            println "Trying pattern "+e2t.getValue().getPattern()+" on \""+str.substring(baseStart,Math.min(baseStart+32,str.length()))+"\"";
            int nextStart = matchPrequel(e2t.getValue().getPattern(),str.substring(baseStart));
            println "Result = "+nextStart;
            if (nextStart < 0) {
                continue;
            }
            nextStart += baseStart;
            // handle switching delimiters, MySQL solution
            if (e2t.getKey() == "DELIMITER") {
                def m = str.substring(nextStart) =~ "^\\s*([^\\s]+)\\s*(\\n|\\r\\n)";
                println "M = "+m;
                if (!m.find()) {
                    throw new StopExecutionException("Incorrect delimiter specification");
                }
                println "M' = "+m;
                delimiter = m.group(1);
                println "Delimiter set to \""+delimiter+"\""
                def m2 = str.substring(nextStart) =~ "^\\s*([^\\s]+)\\s*";
                println "M2 = "+m2;
                m2.find();
                println "M2' = "+m2;
                println "l(m) = "+m.group().length()+", l(m2) = "+m2.group().length();
                println "l(m.g(1) = "+m.group(1).length();
                println "l(m.g(2) = "+m.group(2).length();
                nextStart += m.group().length()-m.group(2).length();
                println "nextStart (DELIMITER) = "+nextStart;
            }
            if (e2t.getValue().getHasId()) {
                def tmp = str.substring(nextStart);
                println "Looking for id in \""+tmp.substring(0,Math.min(32,tmp.length()))+"...\"";
                def m = tmp =~ idPattern;
                if (!m.find()) {
                    return false;
                }
                println "Pattern for id found";
                tmpId = Optional.of(m.group(1).replaceAll("`",""));
                println "Id =" + tmpId;
                nextStart += m.group().length();
                println "m.group() = \""+m.group()+"\""
                println "m.group(1) = \""+m.group(1)+"\""
                
            }
            println "nextStart = "+nextStart;
            println "Rest = \""+str.substring(nextStart,Math.min(nextStart+32,str.length()))+"\"";
            if (e2t.getValue().getEndsWithDelimiter()) {
                tmpEndIndexLastMatch = str.indexOf(delimiter,nextStart);
            } else { // look for newline
                tmpEndIndexLastMatch = str.indexOf("\r\n",nextStart);
                if (tmpEndIndexLastMatch == -1) {
                    tmpEndIndexLastMatch = str.indexOf('\n',nextStart);
                }
            }
            println "tmpEndIndexLastMath = "+tmpEndIndexLastMatch;
            if (tmpEndIndexLastMatch > -1) {
                typeString = e2t.getKey();
                extractedSqlStatement.setType(typeString);
                endIndexLastMatch = index+tmpEndIndexLastMatch+(e2t.getValue().getEndsWithDelimiter()?delimiter.length():1);
                int realStart = 0;
                println "str[0] =\""+str[0]+"\"";
                println "Match = " +str[0] =~ "\\s";
                println "Match = " +(str[0] =~ "\\s").find();
                while (realStart<nextStart+tmpEndIndexLastMatch && (str[realStart] =~ "\\s").find()) {
                    ++realStart;
                }
                println "Real start = "+realStart;
                extractedSqlStatement.setStatement(str.substring(baseStart,tmpEndIndexLastMatch));
                println "Result = "+extractedSqlStatement;
                if (tmpId.isPresent()) {
                    extractedSqlStatement.setId(tmpId.get());
                }
                return true;
            }
        }
        println "matchAnyPrequel result = "+extractedSqlStatement;
        return false;
    }
    private boolean findNextElement(ExtractedSqlStatement extractedSqlStatement) {
        String tmp = str.substring(index);
        if (matchAnyPrequel(tmp,extractedSqlStatement)) {
            println "findNextElement result = "+extractedSqlStatement.getStatement();
            return true;
        } else {
            println "findNextElement result = none";
            return false;
        }
    }
    public SqlScriptIterator(String str) { this.str = str; }
    public boolean hasNext() {
        println "hasNext: extractedSqlStatement.isPresent() = "+extractedSqlStatement.isPresent();
        boolean tmp = index <str.length();
        println "hasNext: index = "+index+ " < str.length() = "+str.length()+ " == " + tmp;
        if (!extractedSqlStatement.isPresent() && (index < str.length())) {
            findNextElement(extractedSqlStatement);
        }
        println "hasNext: extractedSqlStatement.isPresent() = "+extractedSqlStatement.isPresent();
        return extractedSqlStatement.isPresent();
    }
    public ExtractedSqlStatement next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        ExtractedSqlStatement tmp = extractedSqlStatement.clone();
        index = endIndexLastMatch;
        println "next: extractedSqlStatement.isPresent() = "+extractedSqlStatement.isPresent();
        extractedSqlStatement.reset();
        println "next: extractedSqlStatement.isPresent() = "+extractedSqlStatement.isPresent();
        return tmp;
    }
    public void remove() {
    }
    Optional<String> getLastType() {
        return lastType;
    }
    Optional<String> getLastId() {
        return lastId;
    }
    Optional<String> getLastResult() {
        return lastResult;
    }
};

// The embedded connection to MySQL, opened in task OpenDatabaseAsRoot
ext.mysqlRootConnection = ''
def getMysqlRootConnection = {
    return ext.mysqlRootConnection
}
ext.mysqlWhedcappConnection = ''
def getMysqlWhedcappConnection = {
    return ext.mysqlWhedcappConnection
}

// Identities and passwords, all which are set by querying the person
// building the server part

ext.mysqlRootUserId = ''
def getMysqlRootUserId = {
    return ext.mysqlRootUserId
}
ext.mysqlRootPassword = ''
def getMysqlRootPassword = {
    return ext.mysqlRootPassword
}
ext.mysqlWhedcappUserId = ''
def getMysqlWhedcappUserId = {
    return ext.mysqlWhedcappUserId
}
ext.mysqlWhedcappPassword = ''
def getMysqlWhedcappPassword = {
    return ext.mysqlWhedcappPassword
}

def getMysqlWhedcappUserIsCreatedPath = {
    return "${rootProject.buildDir}/"+project(':database').name+"mysqlWhedcappUserIsCreated.txt";
}



def dbCfgSrcFiles = [ "**/*.cs.in", "**/*.sql.in"].inject([]) { acc,val ->acc+project.fileTree(dir: "${projectDir}/src", include: val)}
logger.debug("dbCfgSrcFiles = "+dbCfgSrcFiles.join(", "))
def dbSrcFiles = ["**/*.cs", "**/*.sql"].inject([]) {acc,val -> acc+project.fileTree(dir: "${projectDir}/src", include: val)}
logger.debug("dbSrcFiles = "+dbSrcFiles.join(", "))
def dbUploadFiles = [ dbDefPath(), dbBaseStoredProceduresPath(), dbCrudSqlSrcPath() ]
def dbUploadProgressPath = "${rootProject}/"+project(":database").name+"/dbUploadProgress.json"
def dbUploadOutputFiles = [ dbUploadProgressPath ]

def crudGenerationCfgPrepInputFiles = dbCfgSrcFiles
def crudGenerationPrepInputFiles = dbSrcFiles
def crudOutputFiles = [
    dbCrudSqlSrcPath()
]
logger.debug("crudOutputFiles = "+crudOutputFiles.join(", "))

def crudGenerationCfgPrepOutputFiles = [
    dbDefPath()
]

def crudGenerationPrepOutputFiles = [
    dbCrudCfgPath()
]
logger.debug("crudGenerationPrepOutputFiles = "+crudGenerationPrepOutputFiles.join(", "))
def crudGenerationInputFiles = crudGenerationPrepOutputFiles + [ crudGenToolPath() ]

def crudGenerationOutputFiles = [ dbCrudSqlSrcPath()]

task CrudGenerationCfgPrep() {
     inputs.files(dbCfgSrcFiles)
     outputs.files(crudGenerationCfgPrepOutputFiles)
     doLast {
         def m = [whedcappAdministrator: getWcau() ]
         copy {
             dbCfgSrcFiles.each { p -> from(p) }
             into "${rootProject.buildDir}/${project.name}"
             filter(ReplaceTokens, tokens:m)
             rename '(.*).in', '$1'
         }
         logger.info("outputs = "+crudGenerationCfgPrepOutputFiles.join(", "))
         logger.info("m="+m)
     }
}
task CrudGenerationPrep() {
     dependsOn 'CrudGenerationCfgPrep'
     inputs.files(dbSrcFiles)
     outputs.files(crudGenerationPrepOutputFiles)
     doLast {
         copy {
             dbSrcFiles.each { p -> from(p) }
             into "${rootProject.buildDir}/${project.name}"
         }
     }
}

task CrudGeneration(type:Exec) {
     dependsOn 'CrudGenerationPrep'
     dependsOn 'CrudGenerationCfgPrep'
     if (project.ext.buildType == 'Debug') {
          dependsOn ':crud_gen_tool:CmakeDebugBuild'
     } else {
          dependsOn ':crud_gen_tool:CmakeReleaseBuild'
     }
     workingDir "${rootProject.buildDir}/${project.name}"
     inputs.files(crudGenerationInputFiles)
     outputs.files(crudGenerationOutputFiles)
     group = 'Database'
     description = "Creates CRUD stored procedures based on "+dbDefPath()
     def cmd = crudGenToolPath()
     if (project.ext.traceParser == 'Yes') {
          commandLine cmd,'-p',dbDefPath(),'-c',dbCrudCfgPath(),'-s',dbCrudSqlSrcPath(),'-t'
     } else {
          commandLine cmd,'-p',dbDefPath(),'-c',dbCrudCfgPath(),'-s',dbCrudSqlSrcPath()
     }
     standardOutput = new ByteArrayOutputStream()
     ext.output = {
          return standardOutput.toString();
     }
     doFirst {
             mkdir "${rootProject.buildDir}/${project.name}"
     }
}
tasks.register('OpenDatabaseAsRoot') {
   dependsOn 'CrudGeneration'
   doFirst {
       try {
           def mysql = buildscript.configurations.classpath.find { it.toString().contains("mysql-connector-java") }
           URLClassLoader loader = GroovyObject.class.classLoader
           loader.addURL(file(mysql).toURL())

           def db = [url: "jdbc:mysql://127.0.0.1/",
                  user: getMysqlRootUserId(), password: getMysqlRootPassword(), driver: 'com.mysql.jdbc.Driver']
           logger.info("Password inside open database as root: "+getMysqlRootPassword()+", inside db.password = "+db.password)
           //project.ext.mysqlRootConnection = groovy.sql.Sql.newInstance(db.url, db.user, db.password, db.driver)
           project.ext.mysqlRootConnection = groovy.sql.Sql.newInstance(db.url, db.user, getMysqlRootPassword(), db.driver)
           logger.info("Conn = "+project.ext.mysqlRootConnection)
           logger.info("Conn2 = "+getMysqlRootConnection())
       } catch (SQLException sqex) {
           throw new StopExecutionException("Could not login as mysql administrator "+sqex.toString())
       }
   }
}
tasks.register('CreateWhedcappDatabaseAccessUser') {
    dependsOn 'OpenDatabaseAsRoot'
    def quotify = { p -> "'"+p.collectReplacements({ it == '@' ? '\'@\'' : null })+"'" }
    def backquotify = { p -> "`"+p.collectReplacements({ it == '.' ? '`.`' : null })+"`" }
    def stmt = ''
    doFirst {
        try {
            stmt = getMysqlRootConnection()
            stmt.execute("DROP DATABASE IF EXISTS `whedcapp`");
            stmt.execute("CREATE DATABASE `whedcapp`");
            stmt.execute("USE `whedcapp`");

            stmt.execute("CREATE USER IF NOT EXISTS "+quotify(getMysqlWhedcappUserId())+" IDENTIFIED BY '"+getMysqlWhedcappPassword()+"'");

            // set appropriate privileges for whedcapp access user, essentially only "EXECUTE" stored procedures
            stmt.execute("REVOKE ALL PRIVILEGES ON "+backquotify("whedcapp.*")+" FROM "+quotify(getMysqlWhedcappUserId()));
            stmt.execute("GRANT EXECUTE PRIVILEGES ON "+backquotify("whedcapp.*")+" TO "+quotify(getMysqlWhedcappUserId()));

            // create table for keeping track of if tables need to be reloaded or not
            stmt.execute """
                CREATE TABLE IF NOT EXISTS `whedcapp`.`whedcapp_installation_item_digest`(
                    id_whedcapp_installation_item_digest INTEGER NOT NULL AUTO_INCREMENT,
                    wiid_item_identifier VARCHAR(256) NOT NULL,
                    wiid_item_type VARCHAR(16) NOT NULL,
                    wiid_item_digest VARCHAR(64) NOT NULL,
                    PRIMARY KEY(`id_whedcapp_installation_item_digest`),
                    UNIQUE INDEX `wiid_unique_idx`(`wiid_item_identifier`,`wiid_item_type`)
                )
            """
        } catch (SQLException sqex) {
            throw new StopExecutionException("Could not create default whedcapp user \""+getMysqlWhedcappUserId()+"\""+sqex);
        } finally {
        }
    }
}

task UploadToDatabase() {
     dependsOn 'CrudGeneration'
     dependsOn 'CreateWhedcappDatabaseAccessUser'
     inputs.files(dbUploadFiles)
     outputs.files(dbUploadOutputFiles)
     group = 'Database'
     description = "Uploads database scheme."
     doFirst {
         //def result = dbUploadFiles.length.times { -> new ByteArrayOutputStream() }
         File file = new File(dbDefPath());
         def txt = removeComments(file.text)
         def ssi = new SqlScriptIterator(txt);
         def stmt = getMysqlRootConnection();
         while (ssi.hasNext()) {
             ExtractedSqlStatement sqlCmd = ssi.next();
             logger.info("SQL Start\n"+sqlCmd+"\nSQL End\n");
             if (sqlCmd.getStatement() != "DELIMITER") {
                 stmt.execute sqlCmd.getStatement();
             }
         }
     }
}
task clean() {
     doFirst {
             delete "${rootProject.buildDir}/${project.name}"
             logger.info(removeComments("/* Hello */ old friend"))
     }
}

// Solution based on https://www.timroes.de/using-password-prompts-with-gradle-build-files

gradle.taskGraph.whenReady { taskGraph ->
//  if(taskGraph.hasTask(':database:OpenDatabaseAsRoot')  && !file(getMysqlWhedcappUserIsCreatedPath()).exists()) {
  if(taskGraph.hasTask(':database:OpenDatabaseAsRoot')  && !file(getMysqlWhedcappUserIsCreatedPath()).exists()) {

    def pass = ''
    def user = ''
    if(System.console() == null) {
      new SwingBuilder().edt {
        dialog(modal: true, // Otherwise the build will continue running before you closed the dialog
            title: 'Enter MySQL Root password', // Dialog title
            alwaysOnTop: true, // pretty much what the name says
            resizable: false, // Don't allow the user to resize the dialog
            locationRelativeTo: null, // Place dialog in center of the screen
            pack: true, // We need to pack the dialog (so it will take the size of it's children)
            show: true // Let's show it
        ) {
          vbox { // Put everything below each other
            label(text: "Please enter Root administrator Id:")
            input1 = textField('root')
            label(text: "Please enter key passphrase for MySQL root:")
            input2 = passwordField()
            button(defaultButton: true, text: 'OK', actionPerformed: {
              user = input1.text
              pass = input2.text
              dispose(); // Close dialog
            })
          } // vbox end
        } // dialog end
      } // edt end
    } else {
      userRaw = System.console().read("\nPlease enter database root user name:");
      user = new String(userRaw)
      passRaw = System.console().readPassword("\nPlease enter key passphrase for MySQL root: ")
      pass = new String(passRaw)
    }
    logger.info("User = "+user)
    logger.info("Pass = "+pass)

    if(user.size() <=0 || pass.size() <= 0) {
      throw new InvalidUserDataException("You must enter a root user identity and a password to proceed.")
    }

    project.ext.mysqlRootUserId = user
    project.ext.mysqlRootPassword = pass;

  } // end if has task
} // end whenReady

gradle.taskGraph.whenReady { taskGraph ->
  if(taskGraph.hasTask(':database:CreateWhedcappDatabaseAccessUser')) {

    def pass = ''
    def user = ''
    if(System.console() == null) {
      new SwingBuilder().edt {
        dialog(modal: true, // Otherwise the build will continue running before you closed the dialog
            title: 'Enter MySQL Whedcapp password', // Dialog title
            alwaysOnTop: true, // pretty much what the name says
            resizable: false, // Don't allow the user to resize the dialog
            locationRelativeTo: null, // Place dialog in center of the screen
            pack: true, // We need to pack the dialog (so it will take the size of it's children)
            show: true // Let's show it
        ) {
          vbox { // Put everything below each other
            label(text: "Please enter Whedcapp administrator Id:")
            input1 = textField()
            label(text: "Please enter key passphrase for Whedcapp:")
            input2 = passwordField()
            button(defaultButton: true, text: 'OK', actionPerformed: {
              user = input1.text;
              pass = input2.text; // Set pass variable to value of input field
              dispose(); // Close dialog
            })
          } // vbox end
        } // dialog end
      } // edt end
    } else {
      userRaw = System.console().read("\nPlease enter Whedcapp database user name:");
      user = new String(userRaw)
      passRaw = System.console().readPassword("\nPlease enter key passphrase for Whedcapp: ")
      pass = new String(passRaw)
    }
    logger.info("User 2 = "+user)
    logger.info("Pass 2 = "+pass)

    if(user.size() <=0 || pass.size() <= 0) {
      throw new InvalidUserDataException("You must enter a user identity or password to proceed.")
    }

    project.ext.mysqlWhedcappUserId = user;
    project.ext.mysqlWhedcappPassword = pass;

  } // end if has task
} // end whenReady

// Whedcapp administrator email:

gradle.taskGraph.whenReady { taskGraph ->
  if(taskGraph.hasTask(':database:CrudGenerationCfgPrep') ) {

    def user = ''
    if(System.console() == null) {
      new SwingBuilder().edt {
        dialog(modal: true, // Otherwise the build will continue running before you closed the dialog
            title: 'Enter Whedcapp administrator user identity', // Dialog title
            alwaysOnTop: true, // pretty much what the name says
            resizable: false, // Don't allow the user to resize the dialog
            locationRelativeTo: null, // Place dialog in center of the screen
            pack: true, // We need to pack the dialog (so it will take the size of it's children)
            show: true // Let's show it
        ) {
          vbox { // Put everything below each other
            label(text: "Please enter Whedcapp administrator user identity (email):")
            input = textField()
            button(defaultButton: true, text: 'OK', actionPerformed: {
              user = input.text; // Set pass variable to value of input field
              dispose(); // Close dialog
            })
          } // vbox end
        } // dialog end
      } // edt end
    } else {
      userRaw = System.console().readPassword("\nPlease enter Whedcapp administrator user identity (email): ")
      user = new String(userRaw)
    }

    if(user.size() <= 0) {
      throw new InvalidUserDataException("You must enter a Whedcapp administrator user identity (email) to proceed.")
    }

    project.ext.wcau = user;

  } // end if has task
} // end whenReady
