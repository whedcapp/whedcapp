/*
 This file is part of Whedcapp - Well-being Health Environment Data Collection App - to collect self-evaluated data for research purpose
 Copyright (C) 2020-2021  Jonas Mellin, Catharina Gillsj√∂

 Whedcapp is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Whedcapp is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Whedcapp.  If not, see <https://www.gnu.org/licenses/>.
 */

// Automatically download drivers for Groovy MySQL access.

buildscript{
    repositories{
        jcenter()
    }

    dependencies{
        classpath 'mysql:mysql-connector-java:8.0.23'
    }
}


import groovy.json.JsonException;
import groovy.json.JsonOutput;
import groovy.json.JsonSlurper;
import groovy.transform.AutoClone;
import groovy.swing.SwingBuilder;
import org.apache.tools.ant.filters.*;
import java.io.File;
import java.sql.SQLException
import java.util.Optional
import java.util.regex.*
//import org.apache.commons.io.FileNameUtils


// ExtractedSqlStatement objects represent an SQL statement
// extracted from an SQL script file.

@AutoClone
public  class ExtractedSqlStatement {
    private String statement;
    private String type;
    private String id;
    ExtractedSqlStatement() { statement = type = id = null; }
    public String getStatement() {
        if (!isPresent()) {
            throw new IllegalStateException("ExtractedSqlStatement contains nothing");
        }
        return statement;
    }
    public String getType() {
        if (!isPresent()) {
            throw new IllegalStateException("ExtractedSqlStatement contains nothing");
        }
        return type;
    }
    public String getId() {
        if (!isPresent()) {
            throw new IllegalStateException("ExtractedSqlStatement contains nothing");
        }
        return id;
    }
    public void setStatement(String statement) {
        this.statement = statement;
    }
    public void setType(String type) {
        this.type = type;
    }
    public void setId(String id) {
        this.id = id;
    }
    public boolean isPresent() {
        return statement != null;
    }
    public void reset() {
        statement = type = id = null;
    }
    public String toString() {
        return id + "-> <"+statement+">, ["+type+"]";
    }
};

// This iterator takes a script files without comments and
// returns ExtractedSqlStatements until there are no more.

class SqlScriptIterator implements Iterator<ExtractedSqlStatement> {
    public static class SqlPattern {
        private List<String> pattern;
        private boolean hasId;
        private boolean endsWithDelimiter;
        public SqlPattern(List<String> pattern, boolean hasId, boolean endsWithDelimiter) {
            this.pattern = pattern;
            this.hasId = hasId;
            this.endsWithDelimiter = endsWithDelimiter;
        }
        public List<String> getPattern() {
            return pattern;
        }
        public boolean getHasId() {
            return hasId;
        }
        public boolean getEndsWithDelimiter() {
            return endsWithDelimiter;
        }
    };
    private Logger log;
    private String str;
    private int index = 0;
    private int endIndexLastMatch;
    private ExtractedSqlStatement extractedSqlStatement = new ExtractedSqlStatement();
    private String delimiter = ";";
    private static idPattern = /^(?i)\s*((`[a-z_][a-z0-9_]*`(.?`[a-z_][a-z0-9_]*`|))|([a-z_][a-z0-9_]*(.?[a-z_][a-z0-9_]*|)))/;
    private static Map<String,Map<String,SqlPattern>> expr2type = [
        CREATE: new SqlPattern( ["^(?i)\\s*CREATE","^(?i)\\s*(TABLE|PROCEDURE|FUNCTION|VIEW|TRIGGER|INDEX|DATABASE)","^(?i)\\s*(IF\\s+NOT\\s+EXISTS|)"], true, true),
        DROP: new SqlPattern( ["^(?i)\\s*DROP","^(?i)\\s*(TABLE|PROCEDURE|FUNCTION|VIEW|TRIGGER|INDEX|DATABASE)","^(?i)\\s*(IF\\s+EXISTS|)"], true, true),
        USE: new SqlPattern( ["^(?i)\\s*USE"], true, true),
        INSERT: new SqlPattern([/^(?i)\s*INSERT\s+INTO/], true, true),
        DELIMITER: new SqlPattern( [/^(?i)\s*DELIMITER/], false, false)
    ];

    private int matchPrequel(List<String> lop,final String str) {
        int tmpStart = 0;
        String tmp = str.substring(tmpStart);
        for (String p: lop) {
            def m = tmp =~ p;
            
            if (!m.find()) {
                return -1;
            }
            tmpStart += m.group().length();
            tmp = str.substring(tmpStart);
            
        }
        return tmpStart;
    }
    private int skipSequenceOfDelimiters(final String str) {
        int baseStart = 0;
        while (true) {
            def tmp = str.substring(baseStart);
            def m = tmp =~ "^\\s*";
            m.find();
            if (m.group().length()>-1) {
                int nextDelimiterIndex = str.indexOf(delimiter,baseStart);
                if (nextDelimiterIndex == baseStart+m.group().length()) {
                    baseStart = nextDelimiterIndex+delimiter.length();
                } else {
                    break;
                }
            } else {
                break;
            }
        }
        log.debug("skipSequenceOfDelimiters baseStart = "+baseStart);
        return baseStart;
    }
    private boolean matchAnyPrequel(final String str,ExtractedSqlStatement extractedSqlStatement) {
        Optional<String> tmpId = Optional.empty();
        int tmpEndIndexLastMatch;
        boolean completed=false;
        def typeString = "";
        int baseStart = skipSequenceOfDelimiters(str);
        // insert nextStart here and skip sequences of delimiters
        for (def e2t: expr2type) {
            tmpEndIndexLastMatch = 0;
            log.debug("Trying pattern "+e2t.getValue().getPattern()+" on \""+str.substring(baseStart,Math.min(baseStart+32,str.length()))+"\"");
            int nextStart = matchPrequel(e2t.getValue().getPattern(),str.substring(baseStart));
            log.debug("Result = "+nextStart);
            if (nextStart < 0) {
                continue;
            }
            nextStart += baseStart;
            // handle switching delimiters, MySQL solution
            if (e2t.getKey() == "DELIMITER") {
                def m = str.substring(nextStart) =~ "^\\s*([^\\s]+)\\s*(\\n|\\r\\n)";
                log.debug("M = "+m);
                if (!m.find()) {
                    throw new StopExecutionException("Incorrect delimiter specification");
                }
                log.debug("M' = "+m);
                delimiter = m.group(1);
                log.debug("Delimiter set to \""+delimiter+"\"");
                def m2 = str.substring(nextStart) =~ "^\\s*([^\\s]+)\\s*";
                log.debug("M2 = "+m2);
                m2.find();
                log.debug("M2' = "+m2);
                log.debug("l(m) = "+m.group().length()+", l(m2) = "+m2.group().length());
                log.debug("l(m.g(1) = "+m.group(1).length());
                log.debug("l(m.g(2) = "+m.group(2).length());
                nextStart += m.group().length()-m.group(2).length();
                log.debug("nextStart (DELIMITER) = "+nextStart);
            }
            if (e2t.getValue().getHasId()) {
                def tmp = str.substring(nextStart);
                log.debug("Looking for id in \""+tmp.substring(0,Math.min(32,tmp.length()))+"...\"");
                def m = tmp =~ idPattern;
                if (!m.find()) {
                    return false;
                }
                log.debug("Pattern for id found");
                tmpId = Optional.of(m.group(1).replaceAll("`",""));
                log.debug("Id =" + tmpId);
                nextStart += m.group().length();
                log.debug("m.group() = \""+m.group()+"\"");
                log.debug("m.group(1) = \""+m.group(1)+"\"");
                
            }
            log.debug("nextStart = "+nextStart);
            log.debug("Rest = \""+str.substring(nextStart,Math.min(nextStart+32,str.length()))+"\"");
            if (e2t.getValue().getEndsWithDelimiter()) {
                tmpEndIndexLastMatch = str.indexOf(delimiter,nextStart);
            } else { // look for newline
                tmpEndIndexLastMatch = str.indexOf("\r\n",nextStart);
                if (tmpEndIndexLastMatch == -1) {
                    tmpEndIndexLastMatch = str.indexOf('\n',nextStart);
                }
            }
            log.debug("tmpEndIndexLastMath = "+tmpEndIndexLastMatch);
            if (tmpEndIndexLastMatch > -1) {
                typeString = e2t.getKey();
                extractedSqlStatement.setType(typeString);
                endIndexLastMatch = index+tmpEndIndexLastMatch+(e2t.getValue().getEndsWithDelimiter()?delimiter.length():1);
                int realStart = 0;
                log.debug("str[0] =\""+str[0]+"\"");
                log.debug("Match = " +(str[0] =~ "\\s").toString());
                log.debug("Match = " +(str[0] =~ "\\s").find());
                while (realStart<nextStart+tmpEndIndexLastMatch && (str[realStart] =~ "\\s").find()) {
                    ++realStart;
                }
                log.debug("Real start = "+realStart);
                extractedSqlStatement.setStatement(str.substring(baseStart,tmpEndIndexLastMatch));
                log.debug("Result = "+extractedSqlStatement);
                if (tmpId.isPresent()) {
                    extractedSqlStatement.setId(tmpId.get());
                }
                return true;
            }
        }
        log.debug("matchAnyPrequel result = "+extractedSqlStatement);
        return false;
    }
    private boolean findNextElement(ExtractedSqlStatement extractedSqlStatement) {
        String tmp = str.substring(index);
        if (matchAnyPrequel(tmp,extractedSqlStatement)) {
            log.debug("findNextElement result = "+extractedSqlStatement.getStatement());
            return true;
        } else {
            log.debug("findNextElement result = none");
            return false;
        }
    }
    public SqlScriptIterator(Logger log,String str) { this.str = str; this.log = log; }
    public boolean hasNext() {
        log.debug("hasNext: extractedSqlStatement.isPresent() = "+extractedSqlStatement.isPresent());
        boolean tmp = index <str.length();
        log.debug("hasNext: index = "+index+ " < str.length() = "+str.length()+ " == " + tmp);
        if (!extractedSqlStatement.isPresent() && (index < str.length())) {
            findNextElement(extractedSqlStatement);
        }
        log.debug("hasNext: extractedSqlStatement.isPresent() = "+extractedSqlStatement.isPresent());
        return extractedSqlStatement.isPresent();
    }
    public ExtractedSqlStatement next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        ExtractedSqlStatement tmp = extractedSqlStatement.clone();
        index = endIndexLastMatch;
        log.debug("next: extractedSqlStatement.isPresent() = "+extractedSqlStatement.isPresent());
        extractedSqlStatement.reset();
        log.debug("next: extractedSqlStatement.isPresent() = "+extractedSqlStatement.isPresent());
        return tmp;
    }
    public void remove() {
    }
};

// The embedded connection to MySQL, opened in task OpenDatabaseAsRoot
ext.mysqlRootConnection = ''
def getMysqlRootConnection = {
    return ext.mysqlRootConnection
}
ext.mysqlWhedcappConnection = ''
def getMysqlWhedcappConnection = {
    return ext.mysqlWhedcappConnection
}
ext.mysqlTestWhedcappConnection = ''
def getMysqlTestWhedcappConnection = {
    return ext.mysqlTestWhedcappConnection
}


// Identities and passwords, all which are set by querying the person
// building the server part

class UserPasswordInternal {
    private String user;
    private String password;
    public UserPasswordInternal(final String user, final String password) {
        this.user = user;
        this.password = password;
    }
    public String getUser() {
        return user;
    }
    public String getPassword() {
        return password;
    }
    public String toString() {
        return "User = \""+user+"\", password = \""+password+"\"";
    }
};

class UserPassword {
    private Script script;
    private String context;
    private String user;
    private String password;
    public UserPassword(Script script,String context, String user, String password) {
        this.script = script;
        this.context = context;
        this.user = user;
        this.password = password;
    }
    public String getContext() {
        return context;
    }
    public String getUser() {
        return user;
    }
    public String getPassword() {
        return password;
    }
    public static getJsonPath(Script script,String context) {
        return "${script.rootProject.buildDir}/"+script.project(':database').name+"/"+context+"-up.json";        
    }
    public static File getJsonFile(final Script script,final String context) {
        return new File(getJsonPath(script,context));
    }
    public static getStoredUserPassword(final Script script, final String context) {
        try {
            UserPassword result;
            def slurper = new JsonSlurper();
            def json = slurper.parseText(getJsonFile(script,context).text);
            return new UserPassword(script,context,json.user,json.password);
        } catch (FileNotFoundException fnfe) {
            return null;
        } catch (JsonException je) {
            throw new StopExecutionException("Something is wrong with the JSON of file \""+getJsonPath(context)+"\"");
        }
        
    }
    public saveUserPassword() {
        try {
            def userPasswordFile = getJsonFile(script,context);
            userPasswordFile << JsonOutput.toJson(this);
        } catch (Exception e) {
            throw new StopExecutionException("Could not save user/password"+e);
        }
    }

};

class UserPasswordControl {
    private String context;
    private Boolean requirePassword;
    private String title;
    private String prompt;
    private String defaultUser;
    private String defaultPassword;
    public UserPasswordControl(final String context, final Boolean requirePassword,final String title, final String prompt, final String defaultUser, final String defaultPassword) {
        this.context = context;
        this.requirePassword = requirePassword;
        this.title = title;
        this.prompt = prompt;
        this.defaultUser = defaultUser;
        this.defaultPassword = defaultPassword;
    }
    public String getContext() {
        return context;
    }
    public Boolean getRequirePassword() {
        return requirePassword;
    }
    public String getTitle() {
        return title;
    }
    public String getPrompt() {
        return prompt;
    }
    public String getDefaultUser() {
        return defaultUser;
    }
    public String getDefaultPassword() {
        return defaultPassword;
    }
};

def task2context = [
    ':database:dbs_CrudGenCfgPrep':new UserPasswordControl('whedcappAdministrator',false,'Whedcapp administrator account (not MySQL!)','Enter default Whedcapp administrator user data','',''),
    ':database:dbs_CreateWhedcappDatabaseAccessUser':new UserPasswordControl('whedcappDatabaseAccessUser',true,'Whedcapp MySQL database access account','Enter Whedcapp database access user data','',''),
    ':database:dbs_CreateWhedcappDatabaseTestAccessUser':new UserPasswordControl('whedcappDatabaseTestAccessUser',true,'Whedcapp MySQL database test access account','Enter Whedcapp database test access user data','',''),
    ':database:dbs_OpenDatabaseAsRoot':new UserPasswordControl('whedcappMysqlRoot',true,'MySQL root access account','Enter MySQL root access data','admin','')
];

ext.credentials = [
    'whedcappAdministrator': null
    ,'whedcappDatabaseAccessUser': null
    ,'whedcappDatabaseTestAccessUser': null
    ,'whedcappMysqlRoot': null
];

// Whedcapp admin user identity
ext.wcau = ''
def getWcau = {
    return ext.credentials['whedcappAdministrator'].getUser()
};

ext.mysqlRootUserId = ''
def getMysqlRootUserId = {
    return ext.credentials['whedcappMysqlRoot'].getUser()
}
ext.mysqlRootPassword = ''
def getMysqlRootPassword = {
    return ext.credentials['whedcappMysqlRoot'].getPassword()
}
ext.mysqlWhedcappUserId = ''
def getMysqlWhedcappUserId = {
    return ext.credentials['whedcappDatabaseAccessUser'].getUser()
}
ext.mysqlWhedcappPassword = ''
def getMysqlWhedcappPassword = {
    return ext.credentials['whedcappDatabaseAccessUser'].getPassword()
}

def getMysqlTestWhedcappUserId = {
    return ext.credentials['whedcappDatabaseTestAccessUser'].getUser()
}
def getMysqlTestWhedcappPassword = {
    return ext.credentials['whedcappDatabaseTestAccessUser'].getPassword()
}

def getMysqlWhedcappUserIsCreatedPath = {
    return "${rootProject.buildDir}/"+project(':database').name+"mysqlWhedcappUserIsCreated.txt";
}



def dbs_dbCfgSrcFiles = [ "**/*.cs.in", "**/*.sql.in"].inject([]) { acc,val ->acc+project.fileTree(dir: "${projectDir}/src", include: val)}
logger.info("dbs_dbCfgSrcFiles = "+dbs_dbCfgSrcFiles.join(", "))

def dbs_dbCfgFiles = dbs_dbCfgSrcFiles.inject([]) {acc,val -> acc+ [new File(val.toString().replaceAll("^.*/database/src","${rootProject.buildDir}/"+project(':database').name).replaceAll(".in","")) ]}
logger.info("dbs_dbCfgFiles = "+dbs_dbCfgFiles.join(", "))

def dbs_dbSrcFiles = ["**/*.cs", "**/*.sql"].inject([]) {acc,val -> acc+project.fileTree(dir: "${projectDir}/src", include: val)}
logger.info("dbs_dbSrcFiles = "+dbs_dbSrcFiles.join(", "))

def dbs_dbFiles = dbs_dbSrcFiles.inject([]) {acc,val -> acc+ [new File(val.toString().replaceAll("^.*/database/src","${rootProject.buildDir}/"+project(':database').name).replaceAll(".in","")) ]}
logger.info("dbs_dbFiles = "+dbs_dbFiles.join(", "))

// find all Def.sql and Cfg.cs files sorted according to a number in the file
// name if any, these are the configuration files used to generate the CRUD

def dbs_dbCrudGenInputFiles = (dbs_dbCfgFiles+dbs_dbFiles).findAll { p -> (p.toString() =~ '^/((.+)/)+[0-9]*.*Def\\.sql$').find() || (p.toString() =~ '^/((.+)/)+[0-9]*.*Cfg\\.cs$').find() }.sort { a,b -> a.toString() < b.toString() ? -1 : 1 }
logger.info("dbs_dbCrudGenInputFiles = "+dbs_dbCrudGenInputFiles)

//def dbUploadToDatabaseFiles = ext.dbUploadToDatabaseFiles //[ dbs_dbDefPath(), dbs_storedProceduresPath(), dbs_crudSqlSrcPath() ]
logger.info("dbUploadFilegggggs = "+dbUploadToDatabaseFiles())

// Copy the '*.in' files and replace tokens. This as part of the preparation
// of CRUD generation.

def dbs_crudGenCfgPrepInputFiles = dbs_dbCfgSrcFiles

def dbs_crudGenCfgPrepOutputFiles = dbs_dbCfgFiles

task dbs_CrudGenCfgPrep() {
    inputs.files(dbs_crudGenCfgPrepInputFiles)
    outputs.files(dbs_crudGenCfgPrepOutputFiles)
    doLast {
        def m = [whedcappAdministrator: getWcau() ]
        copy {
            dbs_dbCfgSrcFiles.each { p -> from(p) }
            into "${rootProject.buildDir}/${project.name}"
            filter(ReplaceTokens, tokens:m)
            rename '(.*).in', '$1'
        }
        logger.info("dbs_crudGenCfgPrepOutputFiles = "+dbs_crudGenCfgPrepOutputFiles.join(", "))
        logger.info("m="+m)
    }
}

// Prepare by copying the rest of the specification files for CRUD generation.

def dbs_crudGenPrepInputFiles = dbs_dbSrcFiles
def dbs_crudGenPrepOutputFiles = [
    dbs_crudCfgPath()
]
logger.info("dbs_crudGenPrepOutputFiles = "+dbs_crudGenPrepOutputFiles.join(", "))

task dbs_CrudGenPrep() {
    dependsOn 'dbs_CrudGenCfgPrep'
    inputs.files(dbs_crudGenPrepInputFiles)
    outputs.files(dbs_crudGenPrepOutputFiles)
    doLast {
        copy {
            dbs_dbSrcFiles.each { p -> from(p) }
            into "${rootProject.buildDir}/${project.name}"
        }
    }
}

// Generate the CRUD specification file.

def dbs_crudGenInputFiles = dbs_dbCrudGenInputFiles + [ cgt_crudGenToolPath() ]
logger.info("dbs_crudGenInputFiles = "+dbs_crudGenInputFiles);
def dbs_crudGenOutputFiles = [ dbs_crudSqlSrcPath()]
logger.info("dbs_crudGenOutputFiles = "+dbs_crudGenOutputFiles);

task dbs_CrudGen(type:Exec) {
    dependsOn 'dbs_CrudGenPrep'
    dependsOn 'dbs_CrudGenCfgPrep'
    if (project.ext.buildType == 'Debug') {
        dependsOn ':crud_gen_tool:cgt_CmakeDebugBuild'
    } else {
        dependsOn ':crud_gen_tool:cgt_CmakeReleaseBuild'
    }
    workingDir "${rootProject.buildDir}/${project.name}"
    inputs.files(dbs_crudGenInputFiles)
    outputs.files(dbs_crudGenOutputFiles)
    group = 'Database'
    description = "Creates CRUD stored procedures based on "+dbs_dbDefPath()
    def cmd = cgt_crudGenToolPath()
    if (project.ext.traceParser == 'Yes') {
        commandLine cmd,'-p',dbs_dbDefPath(),'-c',dbs_crudCfgPath(),'-s',dbs_crudSqlSrcPath(),'-t'
    } else {
        commandLine cmd,'-p',dbs_dbDefPath(),'-c',dbs_crudCfgPath(),'-s',dbs_crudSqlSrcPath()
    }
    standardOutput = new ByteArrayOutputStream()
    ext.output = {
        return standardOutput.toString();
    }
    doFirst {
        mkdir "${rootProject.buildDir}/${project.name}"
    }
}
//  ####   #####   ######  #    #
// #    #  #    #  #       ##   #
// #    #  #    #  #####   # #  #
// #    #  #####   #       #  # #
// #    #  #       #       #   ##
//  ####   #       ######  #    #


// #####     ##     #####    ##    #####     ##     ####   ######
// #    #   #  #      #     #  #   #    #   #  #   #       #
// #    #  #    #     #    #    #  #####   #    #   ####   #####
// #    #  ######     #    ######  #    #  ######       #  #
// #    #  #    #     #    #    #  #    #  #    #  #    #  #
// #####   #    #     #    #    #  #####   #    #   ####   ######


//   ##     ####
//  #  #   #
// #    #   ####
// ######       #
// #    #  #    #
// #    #   ####


// #####    ####    ####    #####
// #    #  #    #  #    #     #
// #    #  #    #  #    #     #
// #####   #    #  #    #     #
// #   #   #    #  #    #     #
// #    #   ####    ####      #



task dbs_OpenDatabaseAsRoot() {
    dependsOn 'dbs_CrudGen'
    outputs.upToDateWhen { false }
    
    group = 'Database'
    description 'Opens MySQL Database as an administrator with grant options'
    doFirst {
        try {
            def mysql = buildscript.configurations.classpath.find { it.toString().contains("mysql-connector-java") }
            URLClassLoader loader = GroovyObject.class.classLoader
            loader.addURL(file(mysql).toURL())
            
            def db = [url: "jdbc:mysql://127.0.0.1/",
                      user: getMysqlRootUserId(), password: getMysqlRootPassword(), driver: 'com.mysql.jdbc.Driver']
            logger.debug("Password inside open database as root: "+getMysqlRootPassword()+", inside db.password = "+db.password)
            project.ext.mysqlRootConnection = groovy.sql.Sql.newInstance(db.url, db.user, getMysqlRootPassword(), db.driver)
            logger.info("Conn = "+project.ext.mysqlRootConnection)
            logger.info("Conn2 = "+getMysqlRootConnection())
        } catch (SQLException sqex) {
            throw new StopExecutionException("Could not login as mysql administrator "+sqex.toString())
        }
    }
}

// #####   #####    ####   #####
// #    #  #    #  #    #  #    #
// #    #  #    #  #    #  #    #
// #    #  #####   #    #  #####
// #    #  #   #   #    #  #
// #####   #    #   ####   #


//   ##    #    #  #####
//  #  #   ##   #  #    #
// #    #  # #  #  #    #
// ######  #  # #  #    #
// #    #  #   ##  #    #
// #    #  #    #  #####


// #####   ######   ####   #####   ######    ##     #####  ######
// #    #  #       #    #  #    #  #        #  #      #    #
// #    #  #####   #       #    #  #####   #    #     #    #####
// #####   #       #       #####   #       ######     #    #
// #   #   #       #    #  #   #   #       #    #     #    #
// #    #  ######   ####   #    #  ######  #    #     #    ######


// #####     ##     #####    ##    #####     ##     ####   ######
// #    #   #  #      #     #  #   #    #   #  #   #       #
// #    #  #    #     #    #    #  #####   #    #   ####   #####
// #    #  ######     #    ######  #    #  ######       #  #
// #    #  #    #     #    #    #  #    #  #    #  #    #  #
// #####   #    #     #    #    #  #####   #    #   ####   ######


//    #    ######
//    #    #
//    #    #####
//    #    #
//    #    #
//    #    #


// #    #  ######   ####   ######   ####    ####     ##    #####    #   #
// ##   #  #       #    #  #       #       #        #  #   #    #    # #
// # #  #  #####   #       #####    ####    ####   #    #  #    #     #
// #  # #  #       #       #            #       #  ######  #####      #
// #   ##  #       #    #  #       #    #  #    #  #    #  #   #      #
// #    #  ######   ####   ######   ####    ####   #    #  #    #     #

// If database is to be reinitialized, do that, otherwise, a migration
// should take place. The migration is a future placeholder and is currently
// not supported.

def dbs_DropAndRecreateDatabaseIfNecessaryInputFiles = ((dbs_dbCfgFiles+dbs_dbFiles).findAll { p -> (p.toString() =~ '^/((.+)/)+.*\\.sql').find() }+[dbs_crudSqlSrcPath()]).sort { a,b -> a.toString() > b.toString() ? 1 : -1 }
logger.info("dbs_DropAndRecreateDatabaseIfNecessaryInputFiles = "+dbs_DropAndRecreateDatabaseIfNecessaryInputFiles)
def dbs_DropAndRecreateDatabaseIfNecessaryOutputFile = new File("${rootProject.buildDir}/${project.name}/dbs_DropAndRecreateDatabaseIfNecessary.txt") ;
def dbs_DropAndRecreateDatabaseIfNecessaryOutputFiles = [ dbs_DropAndRecreateDatabaseIfNecessaryOutputFile ];
logger.info("dbs_DropAndRecreateDatabaseIfNecessaryOutputFiles = "+dbs_DropAndRecreateDatabaseIfNecessaryOutputFiles)

task dbs_DropAndRecreateDatabaseIfNecessary() {
    dependsOn 'dbs_OpenDatabaseAsRoot'
    inputs.files(dbs_DropAndRecreateDatabaseIfNecessaryInputFiles);
    outputs.files(dbs_DropAndRecreateDatabaseIfNecessaryOutputFiles);
    group = 'Database'
    description 'If database setup strategy is initialize, then drop and recreate whedcapp database. Use whedcapp database'
    doFirst {
        try {
            def stmt = getMysqlRootConnection()
            if (dbSetupStrategy == 'initialize') {
                stmt.execute("DROP DATABASE IF EXISTS `whedcapp`");
                stmt.execute("CREATE DATABASE `whedcapp`");
            }
            stmt.execute("USE `whedcapp`");
            Date date = new Date();
            dbs_DropAndRecreateDatabaseIfNecessaryOutputFile << "Ready at "+date.toString()+"\n";
        } catch (SQLException sqe) {
            throw new StopExecutionException("Could not setup database: "+sqex);
        }
    }
    
}

//  ####   #####   ######    ##     #####  ######
// #    #  #    #  #        #  #      #    #
// #       #    #  #####   #    #     #    #####
// #       #####   #       ######     #    #
// #    #  #   #   #       #    #     #    #
//  ####   #    #  ######  #    #     #    ######


// #    #  #    #  ######  #####    ####     ##    #####   #####
// #    #  #    #  #       #    #  #    #   #  #   #    #  #    #
// #    #  ######  #####   #    #  #       #    #  #    #  #    #
// # ## #  #    #  #       #    #  #       ######  #####   #####
// ##  ##  #    #  #       #    #  #    #  #    #  #       #
// #    #  #    #  ######  #####    ####   #    #  #       #


// #####     ##     #####    ##    #####     ##     ####   ######
// #    #   #  #      #     #  #   #    #   #  #   #       #
// #    #  #    #     #    #    #  #####   #    #   ####   #####
// #    #  ######     #    ######  #    #  ######       #  #
// #    #  #    #     #    #    #  #    #  #    #  #    #  #
// #####   #    #     #    #    #  #####   #    #   ####   ######


//   ##     ####    ####   ######   ####    ####
//  #  #   #    #  #    #  #       #       #
// #    #  #       #       #####    ####    ####
// ######  #       #       #            #       #
// #    #  #    #  #    #  #       #    #  #    #
// #    #   ####    ####   ######   ####    ####


// #    #   ####   ######  #####
// #    #  #       #       #    #
// #    #   ####   #####   #    #
// #    #       #  #       #####
// #    #  #    #  #       #   #
//  ####    ####   ######  #    #

// Creates the whedcapp database access user with apropriate grants.
// It also creates the table keeping track of installed/executed SQL
// statements and their digests.

def dbs_CreateWhedcappDatabaseAccessUserInputFiles = ((dbs_dbCfgFiles+dbs_dbFiles).findAll { p -> (p.toString() =~ '^/((.+)/)+.*\\.sql').find() }+[dbs_crudSqlSrcPath()]).sort { a,b -> a.toString() > b.toString() ? 1 : -1 }
logger.info("dbs_CreateWhedcappDatabaseAccessUserInputFiles = "+dbs_CreateWhedcappDatabaseAccessUserInputFiles)


def dbs_CreateWhedcappDatabaseAccessUserOutputFile = new File("${rootProject.buildDir}/${project.name}/dbs_CreateWhedcappDatabaseAccessUserReady.txt") 
def dbs_CreateWhedcappDatabaseAccessUserOutputFiles = [ dbs_CreateWhedcappDatabaseAccessUserOutputFile ]

task dbs_CreateWhedcappDatabaseAccessUser() {
    dependsOn 'dbs_DropAndRecreateDatabaseIfNecessary'
    inputs.files(dbs_CreateWhedcappDatabaseAccessUserInputFiles)
    outputs.files(dbs_CreateWhedcappDatabaseAccessUserOutputFiles);
    group = 'Database'
    description 'Create whedcapp database access user as well as tables/triggers/procedures for keeping track of what has been uploaded'
    doFirst {
        def stmt = getMysqlRootConnection()
        try {
            stmt.execute("DROP USER IF EXISTS "+quotifySqlUserId(getMysqlWhedcappUserId()));
            stmt.execute("CREATE USER IF NOT EXISTS "+quotifySqlUserId(getMysqlWhedcappUserId())+" IDENTIFIED BY '"+getMysqlWhedcappPassword()+"'");
        } catch (SQLException sqex) {
            throw new StopExecutionException("Could not create default whedcapp user \""+getMysqlWhedcappUserId()+"\""+sqex);
        }
        try {
            // set appropriate privileges for whedcapp access user, essentially only "EXECUTE" stored procedures
            stmt.execute("REVOKE ALL PRIVILEGES ON "+backquotifySqlId("whedcapp.*")+" FROM "+quotifySqlUserId(getMysqlWhedcappUserId()));
        } catch (SQLException sqex) {
            // ignore that no grants are there to be revoked
            logger.info("sqex.getSQLState() == '42000' =="+(sqex.getSQLState() == '42000'));
            logger.info("sqex.getErrorCode() == 1141 =="+(sqex.getErrorCode() == 1141));
            if (!((sqex.getSQLState() == '42000') && (sqex.getErrorCode() == 1141))) {
                throw new StopExecutionException("Could not create default whedcapp user \""+getMysqlWhedcappUserId()+"\""+sqex+", state = "+sqex.getSQLState()+", "+sqex.getErrorCode());
            }
            
        }
        try {
            stmt.execute("GRANT EXECUTE ON "+backquotifySqlId("whedcapp.*")+" TO "+quotifySqlUserId(getMysqlWhedcappUserId()));
        } catch (SQLException sqex) {
            throw new StopExecutionException("Could not create default whedcapp user \""+getMysqlWhedcappUserId()+"\""+sqex);
        }
        try {

            // create table for keeping track of if tables need to be reloaded or not
            stmt.execute """
                CREATE TABLE IF NOT EXISTS `whedcapp`.`whedcapp_installation_item_digest`(
                    id_whedcapp_installation_item_digest INTEGER NOT NULL AUTO_INCREMENT,
                    wiid_item_identifier VARCHAR(256) NOT NULL,
                    wiid_item_type VARCHAR(16) NOT NULL,
                    wiid_item_type_instance INTEGER NOT NULL,
                    wiid_item_digest VARCHAR(64) NOT NULL,
                    PRIMARY KEY(`id_whedcapp_installation_item_digest`),
                    UNIQUE INDEX `wiid_unique_idx`(`wiid_item_identifier`,`wiid_item_type`,`wiid_item_type_instance`)
                )
            """

            // create trigger to double check that database constraints holds

            stmt.execute """
                    CREATE TRIGGER `whedcapp`.`whedcapp_installation_item_digest_insert_check`
                        BEFORE INSERT
                        ON `whedcapp`.`whedcapp_installation_item_digest` FOR EACH ROW
                    BEGIN
                        DECLARE no_of_types INTEGER;
                        SELECT COUNT(*) INTO no_of_types 
                            FROM `whedcapp`.`whedcapp_installation_item_digest`
                            WHERE 
                                    `wiid_item_identifier` = NEW.wiid_item_identifier 
                                AND
                                    `wiid_item_type` = NEW.wiid_item_type
                                AND
                                    (
                                            (    
                                                    `wiid_item_type` = "INSERT"
                                                AND
                                                    `wiid_item_type_instance` = NEW.wiid_item_type_instance
                                            )
                                        OR
                                            (
                                                `wiid_item_type` <> "INSERT"
                                            )
                                    );
                                        
                        IF no_of_types > 0 THEN
                            IF NEW.wiid_item_type = "CREATE" THEN
                                SIGNAL SQLSTATE  '65535'
                                    SET MESSAGE_TEXT = 'Cannot insert more than one creation of the same identifier';
                            ELSEIF NEW.wiid_item_type = "INSERT" THEN
                                SIGNAL SQLSTATE  '65535'
                                    SET MESSAGE_TEXT = 'Cannot insert more than one insertion with the same type instance of the same identifier';
                            END IF;
                        END IF;
                    END
                    """

            // create helper function or inserting values in the table

            stmt.execute """
                    CREATE FUNCTION `whedcapp`.`insert_whedcapp_installation_item_digest` (identifier VARCHAR(256), type VARCHAR(16), digest VARCHAR(64)) 
                    RETURNS INTEGER DETERMINISTIC
                    BEGIN
                        DECLARE last_id INTEGER;
                        INSERT INTO `whedcapp`.`whedcapp_installation_item_digest`(wiid_item_identifier, wiid_item_type,wiid_item_type_instance, wiid_item_digest)
                            SELECT identifier, type, COUNT(wiid_item_type_instance), digest
                                FROM `whedcapp`.`whedcapp_installation_item_digest`
                                WHERE 
                                        `wiid_item_identifier` = identifier 
                                    AND
                                        `wiid_item_type` = type;
                        IF ROW_COUNT() < 1 THEN
                            SIGNAL SQLSTATE '65534'
                                SET MESSAGE_TEXT = 'Weird, could not insert row into `whedcapp_installation_item_digest`';
                        END IF;
                        RETURN last_insert_id();
                    END;
                    """
            Date date = new Date();
            dbs_CreateWhedcappDatabaseAccessUserOutputFile << "Whedcapp user created at "+date.toString()+"\n";
        } catch (SQLException sqex) {
            throw new StopExecutionException("Could not create default whedcapp user \""+getMysqlWhedcappUserId()+"\""+sqex);
        } finally {
        }
    }
}

// Creates the whedcapp database access user with apropriate grants.
// It also creates the table keeping track of installed/executed SQL
// statements and their digests.

def dbs_CreateWhedcappDatabaseTestAccessUserInputFiles = ((dbs_dbCfgFiles+dbs_dbFiles).findAll { p -> (p.toString() =~ '^/((.+)/)+.*\\.sql').find() }+[dbs_crudSqlSrcPath()]).sort { a,b -> a.toString() > b.toString() ? 1 : -1 }
logger.info("dbs_CreateWhedcappDatabaseTestAccessUserInputFiles = "+dbs_CreateWhedcappDatabaseTestAccessUserInputFiles)


def dbs_CreateWhedcappDatabaseTestAccessUserOutputFile = new File("${rootProject.buildDir}/${project.name}/dbs_CreateWhedcappDatabaseTestAccessUserReady.txt") 
def dbs_CreateWhedcappDatabaseTestAccessUserOutputFiles = [ dbs_CreateWhedcappDatabaseAccessUserOutputFile ]

task dbs_CreateWhedcappDatabaseTestAccessUser() {
    dependsOn 'dbs_DropAndRecreateDatabaseIfNecessary'
    inputs.files(dbs_CreateWhedcappDatabaseTestAccessUserInputFiles)
    outputs.files(dbs_CreateWhedcappDatabaseTestAccessUserOutputFiles);
    group = 'Database'
    description 'Create whedcapp database test access user'
    doFirst {
        def stmt = getMysqlRootConnection()
        try {
            stmt.execute("DROP USER IF EXISTS "+quotifySqlUserId(getMysqlTestWhedcappUserId()));
            stmt.execute("CREATE USER IF NOT EXISTS "+quotifySqlUserId(getMysqlTestWhedcappUserId())+" IDENTIFIED BY '"+getMysqlTestWhedcappPassword()+"'");
            logger.info("Created "+getMysqlTestWhedcappUserId()+" with password "+getMysqlTestWhedcappPassword())
        } catch (SQLException sqex) {
            throw new StopExecutionException("Could not create default whedcapp user \""+getMysqlWhedcappUserId()+"\""+sqex);
        }
        try {
            // set appropriate privileges for whedcapp access user, essentially only "EXECUTE" stored procedures
            stmt.execute("REVOKE ALL PRIVILEGES ON "+backquotifySqlId("whedcapp.*")+" FROM "+quotifySqlUserId(getMysqlTestWhedcappUserId()));
        } catch (SQLException sqex) {
            // ignore that no grants are there to be revoked
            logger.info("sqex.getSQLState() == '42000' =="+(sqex.getSQLState() == '42000'));
            logger.info("sqex.getErrorCode() == 1141 =="+(sqex.getErrorCode() == 1141));
            if (!((sqex.getSQLState() == '42000') && (sqex.getErrorCode() == 1141))) {
                throw new StopExecutionException("Could not create default whedcapp user \""+getMysqlWhedcappUserId()+"\""+sqex+", state = "+sqex.getSQLState()+", "+sqex.getErrorCode());
            }
            
        }
        try {
            stmt.execute("GRANT EXECUTE,SELECT,INSERT ON "+backquotifySqlId("whedcapp.*")+" TO "+quotifySqlUserId(getMysqlTestWhedcappUserId()));
            Date date = new Date();
            dbs_CreateWhedcappDatabaseTestAccessUserOutputFile << "Whedcapp test user created at "+date.toString()+"\n";
        } catch (SQLException sqex) {
            throw new StopExecutionException("Could not create default whedcapp user \""+getMysqlWhedcappUserId()+"\""+sqex);
        }
    }
}

task dbs_OpenDatabaseAsWhedcappDatabaseAccessUser() {
    dependsOn 'dbs_CreateWhedcappDatabaseAccessUser'
    outputs.upToDateWhen { false }
    
    group = 'Database'
    description 'Opens MySQL Database as an whedcapp database access user'
    doFirst {
        try {
            def mysql = buildscript.configurations.classpath.find { it.toString().contains("mysql-connector-java") }
            URLClassLoader loader = GroovyObject.class.classLoader
            loader.addURL(file(mysql).toURL())
            
            logger.info("Password inside open database as whedcapp database access user: "+getMysqlWhedcappPassword())
            def db = [url: "jdbc:mysql://127.0.0.1/",
                      user: getMysqlWhedcappUserId(), password: getMysqlWhedcappPassword(), driver: 'com.mysql.jdbc.Driver']
            logger.info("Password inside open database as whedcapp database access user: "+getMysqlWhedcappPassword()+", inside db.password = "+db.password)
            project.ext.mysqlWhedcappConnection = groovy.sql.Sql.newInstance(db.url, db.user, db.password, db.driver)
            logger.info("Conn = "+project.ext.mysqlWhedcappConnection)
            logger.info("Conn2 = "+getMysqlWhedcappConnection())
        } catch (SQLException sqex) {
            throw new StopExecutionException("Could not login as mysql whedcapp database access user "+sqex.toString())
        }
    }
}
task dbs_OpenDatabaseAsWhedcappDatabaseTestAccessUser() {
    dependsOn 'dbs_CreateWhedcappDatabaseTestAccessUser'
    outputs.upToDateWhen { false }
    
    group = 'Database'
    description 'Opens MySQL Database as an whedcapp database test access user'
    doFirst {
        try {
            def mysql = buildscript.configurations.classpath.find { it.toString().contains("mysql-connector-java") }
            URLClassLoader loader = GroovyObject.class.classLoader
            loader.addURL(file(mysql).toURL())
            
            logger.info("Password inside open database as whedcapp database access user: "+getMysqlTestWhedcappPassword())
            def db = [url: "jdbc:mysql://127.0.0.1/",
                      user: getMysqlTestWhedcappUserId(), password: getMysqlTestWhedcappPassword(), driver: 'com.mysql.jdbc.Driver']
            logger.info("Password inside open database as whedcapp database access user: "+getMysqlTestWhedcappPassword()+", inside db.password = "+db.password)
            project.ext.mysqlTestWhedcappConnection = groovy.sql.Sql.newInstance(db.url, db.user, db.password, db.driver)
            logger.info("Conn = "+project.ext.mysqlTestWhedcappConnection)
            logger.info("Conn2 = "+getMysqlTestWhedcappConnection())
        } catch (SQLException sqex) {
            throw new StopExecutionException("Could not login as mysql whedcapp database access user "+sqex.toString())
        }
    }
}

// #    #  #####   #        ####     ##    #####            #####   ####
// #    #  #    #  #       #    #   #  #   #    #             #    #    #
// #    #  #    #  #       #    #  #    #  #    #             #    #    #
// #    #  #####   #       #    #  ######  #    #             #    #    #
// #    #  #       #       #    #  #    #  #    #             #    #    #
//  ####   #       ######   ####   #    #  #####              #     ####

// #####     ##     #####    ##    #####     ##     ####   ######
// #    #   #  #      #     #  #   #    #   #  #   #       #
// #    #  #    #     #    #    #  #####   #    #   ####   #####
// #    #  ######     #    ######  #    #  ######       #  #
// #    #  #    #     #    #    #  #    #  #    #  #    #  #
// #####   #    #     #    #    #  #####   #    #   ####   ######



// Upload database scheme, base stored procedures and generated CRUD procedures
// to the the database. It stores a digest of the SQL specification in a table
// that is later dumped to a JSON file mapped on identifiers. This is used
// to check if some file has been modified and is planned to be used for
// migration.

def dbs_uploadToDatabaseInputFiles = ((dbs_dbCfgFiles+dbs_dbFiles).findAll { p -> (p.toString() =~ '^/((.+)/)+.*\\.sql').find() }+[dbs_crudSqlSrcPath()]).sort { a,b -> a.toString() > b.toString() ? 1 : -1 }
logger.info("dbs_uploadToDatabaseInputFiles = "+dbs_uploadToDatabaseInputFiles)

def dbs_uploadToDatabaseOutputFiles = [ dbs_uploadToDatabaseTableFingerprintPath() ]
logger.info("dbs_uploadToDatabaseOutputFiles = "+dbs_uploadToDatabaseOutputFiles)

task dbs_UploadToDatabase() {
    dependsOn 'dbs_CrudGen'
    dependsOn 'dbs_CreateWhedcappDatabaseAccessUser'
    inputs.files(dbs_uploadToDatabaseInputFiles)
    outputs.files(dbs_uploadToDatabaseOutputFiles)
    group = 'Database'
    description = "Uploads database scheme."
    doFirst {
        //def result = dbUploadToDatabaseFiles().length.times { -> new ByteArrayOutputStream() }
        def stmt = getMysqlRootConnection();
        dbUploadToDatabaseFiles().each { path ->
            logger.info("Processing \""+path+"\"");
            File file = new File(path);
            logger.info("Opened file \""+path+"\"");
            def txt = removeComments(file.text)
            logger.info("Removed comments from copy of \""+path+"\"");
            def ssi = new SqlScriptIterator(logger,txt);
            logger.info("Created SqlScriptIterator for copy of \""+path+"\"");
            try {
                while (ssi.hasNext()) {
                    ExtractedSqlStatement sqlCmd = ssi.next();
                    logger.info("SQL Start\n"+sqlCmd+"\nSQL End\n");
                    if (sqlCmd.getType() != "DELIMITER") {
                        stmt.execute sqlCmd.getStatement();
                        stmt.execute "SELECT `whedcapp`.`insert_whedcapp_installation_item_digest`(${sqlCmd.getId()},${sqlCmd.getType()},${checksum(sqlCmd.getStatement())})";
                    }
                }
                
            } catch (SQLException sqex) {
                logger.info("Removing ${dbs_DropAndRecreateDatabaseIfNecessaryOutputFile}");
                delete "${dbs_DropAndRecreateDatabaseIfNecessaryOutputFile}";
                throw new StopExecutionException("Something is wrong with SQL Statement: "+sqex);             
            } catch (Exception ex) {
                logger.info("Removing ${dbs_DropAndRecreateDatabaseIfNecessaryOutputFile}");
                delete "${dbs_DropAndRecreateDatabaseIfNecessaryOutputFile}";
                throw new StopExecutionException("Something is wrong, but not with the SQL Statement: "+ex);             
            }
        }
        try {
            
            // open a writer to an output stream associated with the file
            def uploadDatabaseResultFile = new File(dbs_uploadToDatabaseTableFingerprintPath());
            def uploadDatabaseResultOutputStream = uploadDatabaseResultFile.newOutputStream();
            def writer = uploadDatabaseResultOutputStream.newPrintWriter();

            // for each row in the installation item digest table, output
            // digest data that can be checked to see if a SQL definition
            // has changed or not. This can be used to to make decisions
            // concerning if a SQL definition should be uploaded or not
            // and how to handle migration.
            
            stmt.eachRow("SELECT JSON_ARRAYAGG(JSON_OBJECT('identifier',`wiid_item_identifier`,'type',`wiid_item_type`,'type_instance',`wiid_item_type_instance`,'digest',`wiid_item_digest`)) FROM `whedcapp`.`whedcapp_installation_item_digest`") { obj ->
                uploadDatabaseResultFile << obj[0];
            }
            uploadDatabaseResultOutputStream.close();
        } catch (SQLException sqex) {
            logger.info("Removing ${dbs_DropAndRecreateDatabaseIfNecessaryOutputFile}");
            delete "${dbs_DropAndRecreateDatabaseIfNecessaryOutputFile}";
            throw new StopExecutionException("Something is wrong with SQL Statement: "+sqex);             
        } catch (Exception ex) {
            logger.info("Removing ${dbs_DropAndRecreateDatabaseIfNecessaryOutputFile}");
            delete "${dbs_DropAndRecreateDatabaseIfNecessaryOutputFile}";
            throw new StopExecutionException("Something is wrong, but not with the SQL Statement: "+ex);             
        }

        
    }
}
task clean() {
    doFirst {
        delete "${rootProject.buildDir}/${project.name}"
    }
}
task resetCredentials() {
    doFirst {
        task2context.each { task, upc ->
            delete UserPassword.getJsonPath(this,upc.getContext())
        }
    }
}

// Solution based on https://www.timroes.de/using-password-prompts-with-gradle-build-files




def swingit(final UserPasswordControl upc) {
    def user = ''
    def pass = ''
    while (user == '' || ((pass == '' && upc.getRequirePassword()))) {
        new SwingBuilder().edt {
            dialog(modal: true, // Otherwise the build will continue running before you closed the dialog
                   title: upc.getTitle(), // Dialog title
                   alwaysOnTop: true, // pretty much what the name says
                   resizable: false, // Don't allow the user to resize the dialog
                   locationRelativeTo: null, // Place dialog in center of the screen
                   pack: true, // We need to pack the dialog (so it will take the size of it's children)
                   show: true // Let's show it
            ) {
                vbox { // Put everything below each other
                    label(text: upc.getPrompt())
                    input1 = textField(upc.getDefaultUser())
                    if (upc.getRequirePassword()) {
                        label(text: "Please enter key passphrase:")
                        input2 = passwordField()
                    }
                    button(defaultButton: true, text: 'OK', actionPerformed: {
                        user = input1.text
                        if (upc.getRequirePassword()) {
                            pass = input2.text
                        }
                        dispose(); // Close dialog
                    })
                } // vbox end
            } // dialog end
        } // edt end
    }
    return [user,pass];
}
gradle.taskGraph.whenReady { taskGraph ->
    mkdir "${rootProject.buildDir}/${project.name}"
    def user = '', pass = ''

    // iterate over credentials
    task2context.each { task,upc ->
        // if associated task is to be evaluated, then
        if (taskGraph.hasTask(task)) {
            logger.info("Require password:"+upc.getRequirePassword())
            // fetch stored credentials, if any
            def up = UserPassword.getStoredUserPassword(this,upc.getContext());
            if (up == null) {
                // get the user name/password
                if(System.console() == null) {
                    (user,pass) = swingit(upc);
                } else {
                    userRaw = System.console().read("\n"+upc.getPromptOrTitle()+":");
                    user = new String(userRaw)
                    if (upc.requirePassword()) {
                        passRaw = System.console().readPassword("\nPlease enter key passphrase: ")
                        pass = new String(passRaw)
                    }
                } // if (System.console()
                UserPassword up2 = new UserPassword(this,upc.getContext(),user,pass);
                up2.saveUserPassword();
                
            } else {
                user = up.getUser();
                pass = up.getPassword();
            } // if (up == null)
            ext.credentials[upc.getContext()] = new UserPasswordInternal(user,pass);
            logger.info("Credentials ["+upc.getContext()+"] = "+ext.credentials[upc.getContext()])
        } // if (taskGraph.hasTask())
    } // task2context.each {
}
