/*
  This file is part of Whedcapp - Well-being Health Environment Data Collection App - to collect self-evaluated data for research purpose
  Copyright (C) 2020-2021  Jonas Mellin, Catharina Gillsj√∂

  Whedcapp is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Whedcapp is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with Whedcapp.  If not, see <https://www.gnu.org/licenses/>.
*/

buildscript{
    repositories{
        jcenter()
    }

    dependencies{
        classpath 'mysql:mysql-connector-java:8.0.23'
    }
}


import groovy.json.JsonOutput;
import groovy.transform.AutoClone;
import groovy.swing.SwingBuilder;
import org.apache.tools.ant.filters.*;
import java.io.File;
import java.sql.SQLException
import java.util.Optional
import java.util.regex.*
//import org.apache.commons.io.FileNameUtils

// Whedcapp admin user identity
ext.wcau = ''
def getWcau = {
    return ext.wcau
};

@AutoClone
public  class ExtractedSqlStatement {
    private String statement;
    private String type;
    private String id;
    ExtractedSqlStatement() { statement = type = id = null; }
    public String getStatement() {
        if (!isPresent()) {
            throw new IllegalStateException("ExtractedSqlStatement contains nothing");
        }
        return statement;
    }
    public String getType() {
        if (!isPresent()) {
            throw new IllegalStateException("ExtractedSqlStatement contains nothing");
        }
        return type;
    }
    public String getId() {
        if (!isPresent()) {
            throw new IllegalStateException("ExtractedSqlStatement contains nothing");
        }
        return id;
    }
    public void setStatement(String statement) {
        this.statement = statement;
    }
    public void setType(String type) {
        this.type = type;
    }
    public void setId(String id) {
        this.id = id;
    }
    public boolean isPresent() {
        return statement != null;
    }
    public void reset() {
        statement = type = id = null;
    }
    public String toString() {
        return id + "-> <"+statement+">, ["+type+"]";
    }
};

class SqlScriptIterator implements Iterator<ExtractedSqlStatement> {
    public static class SqlPattern {
        private List<String> pattern;
        private boolean hasId;
        private boolean endsWithDelimiter;
        public SqlPattern(List<String> pattern, boolean hasId, boolean endsWithDelimiter) {
            this.pattern = pattern;
            this.hasId = hasId;
            this.endsWithDelimiter = endsWithDelimiter;
        }
        public List<String> getPattern() {
            return pattern;
        }
        public boolean getHasId() {
            return hasId;
        }
        public boolean getEndsWithDelimiter() {
            return endsWithDelimiter;
        }
    };
    private Logger log;
    private String str;
    private int index = 0;
    private int endIndexLastMatch;
    private ExtractedSqlStatement extractedSqlStatement = new ExtractedSqlStatement();
    private String delimiter = ";";
    private static idPattern = /^(?i)\s*((`[a-z_][a-z0-9_]*`(.?`[a-z_][a-z0-9_]*`|))|([a-z_][a-z0-9_]*(.?[a-z_][a-z0-9_]*|)))/;
    private static Map<String,Map<String,SqlPattern>> expr2type = [
        CREATE: new SqlPattern( ["^(?i)\\s*CREATE","^(?i)\\s*(TABLE|PROCEDURE|FUNCTION|VIEW|TRIGGER|INDEX|DATABASE)","^(?i)\\s*(IF\\s+NOT\\s+EXISTS|)"], true, true),
        DROP: new SqlPattern( ["^(?i)\\s*DROP","^(?i)\\s*(TABLE|PROCEDURE|FUNCTION|VIEW|TRIGGER|INDEX|DATABASE)","^(?i)\\s*(IF\\s+EXISTS|)"], true, true),
        USE: new SqlPattern( ["^(?i)\\s*USE"], true, true),
        INSERT: new SqlPattern([/^(?i)\s*INSERT\s+INTO/], true, true),
        DELIMITER: new SqlPattern( [/^(?i)\s*DELIMITER/], false, false)
    ];

    private int matchPrequel(List<String> lop,final String str) {
        int tmpStart = 0;
        String tmp = str.substring(tmpStart);
        for (String p: lop) {
            def m = tmp =~ p;
            
            if (!m.find()) {
                return -1;
            }
            tmpStart += m.group().length();
            tmp = str.substring(tmpStart);
            
        }
        return tmpStart;
    }
    private int skipSequenceOfDelimiters(final String str) {
        int baseStart = 0;
        while (true) {
            def tmp = str.substring(baseStart);
            def m = tmp =~ "^\\s*";
            m.find();
            if (m.group().length()>-1) {
                int nextDelimiterIndex = str.indexOf(delimiter,baseStart);
                if (nextDelimiterIndex == baseStart+m.group().length()) {
                    baseStart = nextDelimiterIndex+delimiter.length();
                } else {
                    break;
                }
            } else {
                break;
            }
        }
        log.debug("skipSequenceOfDelimiters baseStart = "+baseStart);
        return baseStart;
    }
    private boolean matchAnyPrequel(final String str,ExtractedSqlStatement extractedSqlStatement) {
        Optional<String> tmpId = Optional.empty();
        int tmpEndIndexLastMatch;
        boolean completed=false;
        def typeString = "";
        int baseStart = skipSequenceOfDelimiters(str);
        // insert nextStart here and skip sequences of delimiters
        for (def e2t: expr2type) {
            tmpEndIndexLastMatch = 0;
            log.debug("Trying pattern "+e2t.getValue().getPattern()+" on \""+str.substring(baseStart,Math.min(baseStart+32,str.length()))+"\"");
            int nextStart = matchPrequel(e2t.getValue().getPattern(),str.substring(baseStart));
            log.debug("Result = "+nextStart);
            if (nextStart < 0) {
                continue;
            }
            nextStart += baseStart;
            // handle switching delimiters, MySQL solution
            if (e2t.getKey() == "DELIMITER") {
                def m = str.substring(nextStart) =~ "^\\s*([^\\s]+)\\s*(\\n|\\r\\n)";
                log.debug("M = "+m);
                if (!m.find()) {
                    throw new StopExecutionException("Incorrect delimiter specification");
                }
                log.debug("M' = "+m);
                delimiter = m.group(1);
                log.debug("Delimiter set to \""+delimiter+"\"");
                def m2 = str.substring(nextStart) =~ "^\\s*([^\\s]+)\\s*";
                log.debug("M2 = "+m2);
                m2.find();
                log.debug("M2' = "+m2);
                log.debug("l(m) = "+m.group().length()+", l(m2) = "+m2.group().length());
                log.debug("l(m.g(1) = "+m.group(1).length());
                log.debug("l(m.g(2) = "+m.group(2).length());
                nextStart += m.group().length()-m.group(2).length();
                log.debug("nextStart (DELIMITER) = "+nextStart);
            }
            if (e2t.getValue().getHasId()) {
                def tmp = str.substring(nextStart);
                log.debug("Looking for id in \""+tmp.substring(0,Math.min(32,tmp.length()))+"...\"");
                def m = tmp =~ idPattern;
                if (!m.find()) {
                    return false;
                }
                log.debug("Pattern for id found");
                tmpId = Optional.of(m.group(1).replaceAll("`",""));
                log.debug("Id =" + tmpId);
                nextStart += m.group().length();
                log.debug("m.group() = \""+m.group()+"\"");
                log.debug("m.group(1) = \""+m.group(1)+"\"");
                
            }
            log.debug("nextStart = "+nextStart);
            log.debug("Rest = \""+str.substring(nextStart,Math.min(nextStart+32,str.length()))+"\"");
            if (e2t.getValue().getEndsWithDelimiter()) {
                tmpEndIndexLastMatch = str.indexOf(delimiter,nextStart);
            } else { // look for newline
                tmpEndIndexLastMatch = str.indexOf("\r\n",nextStart);
                if (tmpEndIndexLastMatch == -1) {
                    tmpEndIndexLastMatch = str.indexOf('\n',nextStart);
                }
            }
            log.debug("tmpEndIndexLastMath = "+tmpEndIndexLastMatch);
            if (tmpEndIndexLastMatch > -1) {
                typeString = e2t.getKey();
                extractedSqlStatement.setType(typeString);
                endIndexLastMatch = index+tmpEndIndexLastMatch+(e2t.getValue().getEndsWithDelimiter()?delimiter.length():1);
                int realStart = 0;
                log.debug("str[0] =\""+str[0]+"\"");
                log.debug("Match = " +(str[0] =~ "\\s").toString());
                log.debug("Match = " +(str[0] =~ "\\s").find());
                while (realStart<nextStart+tmpEndIndexLastMatch && (str[realStart] =~ "\\s").find()) {
                    ++realStart;
                }
                log.debug("Real start = "+realStart);
                extractedSqlStatement.setStatement(str.substring(baseStart,tmpEndIndexLastMatch));
                log.debug("Result = "+extractedSqlStatement);
                if (tmpId.isPresent()) {
                    extractedSqlStatement.setId(tmpId.get());
                }
                return true;
            }
        }
        log.debug("matchAnyPrequel result = "+extractedSqlStatement);
        return false;
    }
    private boolean findNextElement(ExtractedSqlStatement extractedSqlStatement) {
        String tmp = str.substring(index);
        if (matchAnyPrequel(tmp,extractedSqlStatement)) {
            log.debug("findNextElement result = "+extractedSqlStatement.getStatement());
            return true;
        } else {
            log.debug("findNextElement result = none");
            return false;
        }
    }
    public SqlScriptIterator(Logger log,String str) { this.str = str; this.log = log; }
    public boolean hasNext() {
        log.debug("hasNext: extractedSqlStatement.isPresent() = "+extractedSqlStatement.isPresent());
        boolean tmp = index <str.length();
        log.debug("hasNext: index = "+index+ " < str.length() = "+str.length()+ " == " + tmp);
        if (!extractedSqlStatement.isPresent() && (index < str.length())) {
            findNextElement(extractedSqlStatement);
        }
        log.debug("hasNext: extractedSqlStatement.isPresent() = "+extractedSqlStatement.isPresent());
        return extractedSqlStatement.isPresent();
    }
    public ExtractedSqlStatement next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        ExtractedSqlStatement tmp = extractedSqlStatement.clone();
        index = endIndexLastMatch;
        log.debug("next: extractedSqlStatement.isPresent() = "+extractedSqlStatement.isPresent());
        extractedSqlStatement.reset();
        log.debug("next: extractedSqlStatement.isPresent() = "+extractedSqlStatement.isPresent());
        return tmp;
    }
    public void remove() {
    }
};

// The embedded connection to MySQL, opened in task OpenDatabaseAsRoot
ext.mysqlRootConnection = ''
def getMysqlRootConnection = {
    return ext.mysqlRootConnection
}
ext.mysqlWhedcappConnection = ''
def getMysqlWhedcappConnection = {
    return ext.mysqlWhedcappConnection
}

// Identities and passwords, all which are set by querying the person
// building the server part

ext.mysqlRootUserId = ''
def getMysqlRootUserId = {
    return ext.mysqlRootUserId
}
ext.mysqlRootPassword = ''
def getMysqlRootPassword = {
    return ext.mysqlRootPassword
}
ext.mysqlWhedcappUserId = ''
def getMysqlWhedcappUserId = {
    return ext.mysqlWhedcappUserId
}
ext.mysqlWhedcappPassword = ''
def getMysqlWhedcappPassword = {
    return ext.mysqlWhedcappPassword
}

def getMysqlWhedcappUserIsCreatedPath = {
    return "${rootProject.buildDir}/"+project(':database').name+"mysqlWhedcappUserIsCreated.txt";
}



def dbCfgSrcFiles = [ "**/*.cs.in", "**/*.sql.in"].inject([]) { acc,val ->acc+project.fileTree(dir: "${projectDir}/src", include: val)}
logger.debug("dbCfgSrcFiles = "+dbCfgSrcFiles.join(", "))
def dbSrcFiles = ["**/*.cs", "**/*.sql"].inject([]) {acc,val -> acc+project.fileTree(dir: "${projectDir}/src", include: val)}
logger.debug("dbSrcFiles = "+dbSrcFiles.join(", "))
def dbUploadFiles = [ dbDefPath(), dbBaseStoredProceduresPath(), dbCrudSqlSrcPath() ]
def dbUploadProgressPath = "${rootProject.buildDir}/"+project(":database").name+"/dbUploadProgress.json"
def dbUploadOutputFiles = [ dbUploadProgressPath ]

def crudGenerationCfgPrepInputFiles = dbCfgSrcFiles
def crudGenerationPrepInputFiles = dbSrcFiles
def crudOutputFiles = [
    dbCrudSqlSrcPath()
]
logger.info("crudOutputFiles = "+crudOutputFiles.join(", "))

def crudGenerationCfgPrepOutputFiles = [
    dbDefPath()
]

def crudGenerationPrepOutputFiles = [
    dbCrudCfgPath()
]
logger.info("crudGenerationPrepOutputFiles = "+crudGenerationPrepOutputFiles.join(", "))
def crudGenerationInputFiles = crudGenerationPrepOutputFiles + [ crudGenToolPath() ]

def crudGenerationOutputFiles = [ dbCrudSqlSrcPath()]

task CrudGenerationCfgPrep() {
     inputs.files(dbCfgSrcFiles)
     outputs.files(crudGenerationCfgPrepOutputFiles)
     doLast {
         def m = [whedcappAdministrator: getWcau() ]
         copy {
             dbCfgSrcFiles.each { p -> from(p) }
             into "${rootProject.buildDir}/${project.name}"
             filter(ReplaceTokens, tokens:m)
             rename '(.*).in', '$1'
         }
         logger.info("outputs = "+crudGenerationCfgPrepOutputFiles.join(", "))
         logger.info("m="+m)
     }
}
task CrudGenerationPrep() {
    dependsOn 'CrudGenerationCfgPrep'
    inputs.files(dbSrcFiles)
    outputs.files(crudGenerationPrepOutputFiles)
    doLast {
        copy {
            dbSrcFiles.each { p -> from(p) }
            into "${rootProject.buildDir}/${project.name}"
        }
    }
}

task CrudGeneration(type:Exec) {
    dependsOn 'CrudGenerationPrep'
    dependsOn 'CrudGenerationCfgPrep'
    if (project.ext.buildType == 'Debug') {
        dependsOn ':crud_gen_tool:CmakeDebugBuild'
    } else {
        dependsOn ':crud_gen_tool:CmakeReleaseBuild'
    }
    workingDir "${rootProject.buildDir}/${project.name}"
    inputs.files(crudGenerationInputFiles)
    outputs.files(crudGenerationOutputFiles)
    group = 'Database'
    description = "Creates CRUD stored procedures based on "+dbDefPath()
    def cmd = crudGenToolPath()
    if (project.ext.traceParser == 'Yes') {
        commandLine cmd,'-p',dbDefPath(),'-c',dbCrudCfgPath(),'-s',dbCrudSqlSrcPath(),'-t'
    } else {
        commandLine cmd,'-p',dbDefPath(),'-c',dbCrudCfgPath(),'-s',dbCrudSqlSrcPath()
    }
    standardOutput = new ByteArrayOutputStream()
    ext.output = {
        return standardOutput.toString();
    }
    doFirst {
        mkdir "${rootProject.buildDir}/${project.name}"
    }
}
task OpenDatabaseAsRoot() {
    dependsOn 'CrudGeneration'
    inputs.files(dbUploadFiles)
    outputs.files(dbUploadOutputFiles)
    group = 'Database'
    description 'Opens MySQL Database as an administrator with grant options'
    doFirst {
        try {
            def mysql = buildscript.configurations.classpath.find { it.toString().contains("mysql-connector-java") }
            URLClassLoader loader = GroovyObject.class.classLoader
            loader.addURL(file(mysql).toURL())
            
            def db = [url: "jdbc:mysql://127.0.0.1/",
                      user: getMysqlRootUserId(), password: getMysqlRootPassword(), driver: 'com.mysql.jdbc.Driver']
            logger.info("Password inside open database as root: "+getMysqlRootPassword()+", inside db.password = "+db.password)
            //project.ext.mysqlRootConnection = groovy.sql.Sql.newInstance(db.url, db.user, db.password, db.driver)
            project.ext.mysqlRootConnection = groovy.sql.Sql.newInstance(db.url, db.user, getMysqlRootPassword(), db.driver)
            logger.info("Conn = "+project.ext.mysqlRootConnection)
            logger.info("Conn2 = "+getMysqlRootConnection())
        } catch (SQLException sqex) {
            throw new StopExecutionException("Could not login as mysql administrator "+sqex.toString())
        }
    }
}
task DropAndRecreateDatabaseIfNecessary() {
    dependsOn 'OpenDatabaseAsRoot'
    inputs.files(dbUploadFiles)
    outputs.files(dbUploadOutputFiles)
    group = 'Database'
    description 'If database setup strategy is initialize, then drop and recreate whedcapp database. Use whedcapp database'
    doFirst {
        try {
            def stmt = getMysqlRootConnection()
            if (dbSetupStrategy == 'initialize') {
                stmt.execute("DROP DATABASE IF EXISTS `whedcapp`");
                stmt.execute("CREATE DATABASE `whedcapp`");
            }
            stmt.execute("USE `whedcapp`");
        } catch (SQLException sqe) {
            throw new StopExecutionException("Could not setup database: "+sqex);
        }
    }
    
}
task CreateWhedcappDatabaseAccessUser() {
    dependsOn 'OpenDatabaseAsRoot'
    dependsOn 'DropAndRecreateDatabaseIfNecessary'
    inputs.files(dbUploadFiles)
    outputs.files(dbUploadOutputFiles)
    group = 'Database'
    description 'Create whedcapp database access user as well as tables/triggers/procedures for keeping track of what has been uploaded'
    doFirst {
        def stmt = getMysqlRootConnection()
        try {

            stmt.execute("CREATE USER IF NOT EXISTS "+quotifySqlUserId(getMysqlWhedcappUserId())+" IDENTIFIED BY '"+getMysqlWhedcappPassword()+"'");
        } catch (SQLException sqex) {
            throw new StopExecutionException("Could not create default whedcapp user \""+getMysqlWhedcappUserId()+"\""+sqex);
        }
        try {
            // set appropriate privileges for whedcapp access user, essentially only "EXECUTE" stored procedures
            stmt.execute("REVOKE ALL PRIVILEGES ON "+backquotifySqlId("whedcapp.*")+" FROM "+quotifySqlUserId(getMysqlWhedcappUserId()));
        } catch (SQLException sqex) {
            // ignor that no grants are there to be revoked
            logger.info("sqex.getSQLState() == '42000' =="+(sqex.getSQLState() == '42000'));
            logger.info("sqex.getErrorCode() == 1141 =="+(sqex.getErrorCode() == 1141));
            if (!((sqex.getSQLState() == '42000') && (sqex.getErrorCode() == 1141))) {
                throw new StopExecutionException("Could not create default whedcapp user \""+getMysqlWhedcappUserId()+"\""+sqex+", state = "+sqex.getSQLState()+", "+sqex.getErrorCode());
            }
            
        }
        try {
            stmt.execute("GRANT EXECUTE ON "+backquotifySqlId("whedcapp.*")+" TO "+quotifySqlUserId(getMysqlWhedcappUserId()));
        } catch (SQLException sqex) {
            throw new StopExecutionException("Could not create default whedcapp user \""+getMysqlWhedcappUserId()+"\""+sqex);
        }
        try {
            // create table for keeping track of if tables need to be reloaded or not
            stmt.execute """
                CREATE TABLE IF NOT EXISTS `whedcapp`.`whedcapp_installation_item_digest`(
                    id_whedcapp_installation_item_digest INTEGER NOT NULL AUTO_INCREMENT,
                    wiid_item_identifier VARCHAR(256) NOT NULL,
                    wiid_item_type VARCHAR(16) NOT NULL,
                    wiid_item_type_instance INTEGER NOT NULL,
                    wiid_item_digest VARCHAR(64) NOT NULL,
                    PRIMARY KEY(`id_whedcapp_installation_item_digest`),
                    UNIQUE INDEX `wiid_unique_idx`(`wiid_item_identifier`,`wiid_item_type`,`wiid_item_type_instance`)
                )
            """
            stmt.execute """
                    CREATE TRIGGER `whedcapp`.`whedcapp_installation_item_digest_insert_check`
                        BEFORE INSERT
                        ON `whedcapp`.`whedcapp_installation_item_digest` FOR EACH ROW
                    BEGIN
                        DECLARE no_of_types INTEGER;
                        SELECT COUNT(*) INTO no_of_types 
                            FROM `whedcapp`.`whedcapp_installation_item_digest`
                            WHERE 
                                    `wiid_item_identifier` = NEW.wiid_item_identifier 
                                AND
                                    `wiid_item_type` = NEW.wiid_item_type
                                AND
                                    (
                                            (    
                                                    `wiid_item_type` = "INSERT"
                                                AND
                                                    `wiid_item_type_instance` = NEW.wiid_item_type_instance
                                            )
                                        OR
                                            (
                                                `wiid_item_type` <> "INSERT"
                                            )
                                    );
                                        
                        IF no_of_types > 0 THEN
                            IF NEW.wiid_item_type = "CREATE" THEN
                                SIGNAL SQLSTATE  '65535'
                                    SET MESSAGE_TEXT = 'Cannot insert more than one creation of the same identifier';
                            ELSEIF NEW.wiid_item_type = "INSERT" THEN
                                SIGNAL SQLSTATE  '65535'
                                    SET MESSAGE_TEXT = 'Cannot insert more than one insertion with the same type instance of the same identifier';
                            END IF;
                        END IF;
                    END
                    """
            stmt.execute """
                    CREATE FUNCTION `whedcapp`.`insert_whedcapp_installation_item_digest` (identifier VARCHAR(256), type VARCHAR(16), digest VARCHAR(64)) 
                    RETURNS INTEGER DETERMINISTIC
                    BEGIN
                        DECLARE last_id INTEGER;
                        INSERT INTO `whedcapp`.`whedcapp_installation_item_digest`(wiid_item_identifier, wiid_item_type,wiid_item_type_instance, wiid_item_digest)
                            SELECT identifier, type, COUNT(wiid_item_type_instance), digest
                                FROM `whedcapp`.`whedcapp_installation_item_digest`
                                WHERE 
                                        `wiid_item_identifier` = identifier 
                                    AND
                                        `wiid_item_type` = type;
                        IF ROW_COUNT() < 1 THEN
                            SIGNAL SQLSTATE '65534'
                                SET MESSAGE_TEXT = 'Weird, could not insert row into `whedcapp_installation_item_digest`';
                        END IF;
                        RETURN last_insert_id();
                    END;
                    """
        } catch (SQLException sqex) {
            throw new StopExecutionException("Could not create default whedcapp user \""+getMysqlWhedcappUserId()+"\""+sqex);
        } finally {
        }
    }
}

task UploadToDatabase() {
    dependsOn 'CrudGeneration'
    dependsOn 'CreateWhedcappDatabaseAccessUser'
    inputs.files(dbUploadFiles)
    outputs.files(dbUploadOutputFiles)
    group = 'Database'
    description = "Uploads database scheme."
    doFirst {
        //def result = dbUploadFiles.length.times { -> new ByteArrayOutputStream() }
        def stmt = getMysqlRootConnection();
        dbUploadFiles.each { path ->
            logger.info("Processing \""+path+"\"");
            File file = new File(path);
            logger.info("Opened file \""+path+"\"");
            def txt = removeComments(file.text)
            logger.info("Removed comments from copy of \""+path+"\"");
            def ssi = new SqlScriptIterator(logger,txt);
            logger.info("Created SqlScriptIterator for copy of \""+path+"\"");
            try {
                while (ssi.hasNext()) {
                    ExtractedSqlStatement sqlCmd = ssi.next();
                    logger.info("SQL Start\n"+sqlCmd+"\nSQL End\n");
                    if (sqlCmd.getType() != "DELIMITER") {
                        stmt.execute sqlCmd.getStatement();
                        stmt.execute "SELECT `whedcapp`.`insert_whedcapp_installation_item_digest`(${sqlCmd.getId()},${sqlCmd.getType()},${checksum(sqlCmd.getStatement())})";
                    }
                }
            
            } catch (SQLException sqex) {
                throw new StopExecutionException("Something is wrong with SQL Statement: "+sqex);             
            } catch (Exception ex) {
                throw new StopExecutionException("Something is wrong, but not with the SQL Statement: "+ex);             
            }
        }
        try {
            def uploadDatabaseResultFile = new File(dbUploadProgressPath);
            def uploadDatabaseResultOutputStream = uploadDatabaseResultFile.newOutputStream();
            def writer = uploadDatabaseResultOutputStream.newPrintWriter();
            stmt.eachRow("SELECT JSON_ARRAYAGG(JSON_OBJECT('identifier',`wiid_item_identifier`,'type',`wiid_item_type`,'type_instance',`wiid_item_type_instance`,'digest',`wiid_item_digest`)) FROM `whedcapp`.`whedcapp_installation_item_digest`") { obj ->
                logger.info(obj[0]);
                logger.info(obj[0].getClass().getName());
                //writer.writeLine(obj[0].toString());
                uploadDatabaseResultFile << obj[0];
            }
            uploadDatabaseResultOutputStream.close();
        } catch (SQLException sqex) {
            throw new StopExecutionException("Something is wrong with SQL Statement: "+sqex);             
        } catch (Exception ex) {
            throw new StopExecutionException("Something is wrong, but not with the SQL Statement: "+ex);             
        }

            
    }
}
task clean() {
     doFirst {
             delete "${rootProject.buildDir}/${project.name}"
             logger.info(removeComments("/* Hello */ old friend"))
     }
}

// Solution based on https://www.timroes.de/using-password-prompts-with-gradle-build-files

gradle.taskGraph.whenReady { taskGraph ->
//  if(taskGraph.hasTask(':database:OpenDatabaseAsRoot')  && !file(getMysqlWhedcappUserIsCreatedPath()).exists()) {
  if(taskGraph.hasTask(':database:OpenDatabaseAsRoot')  && !file(getMysqlWhedcappUserIsCreatedPath()).exists()) {

    def pass = ''
    def user = ''
    if(System.console() == null) {
      new SwingBuilder().edt {
        dialog(modal: true, // Otherwise the build will continue running before you closed the dialog
            title: 'Enter MySQL Root password', // Dialog title
            alwaysOnTop: true, // pretty much what the name says
            resizable: false, // Don't allow the user to resize the dialog
            locationRelativeTo: null, // Place dialog in center of the screen
            pack: true, // We need to pack the dialog (so it will take the size of it's children)
            show: true // Let's show it
        ) {
          vbox { // Put everything below each other
            label(text: "Please enter Root administrator Id:")
            input1 = textField('admin')
            label(text: "Please enter key passphrase for MySQL root:")
            input2 = passwordField()
            button(defaultButton: true, text: 'OK', actionPerformed: {
              user = input1.text
              pass = input2.text
              dispose(); // Close dialog
            })
          } // vbox end
        } // dialog end
      } // edt end
    } else {
      userRaw = System.console().read("\nPlease enter database root user name:");
      user = new String(userRaw)
      passRaw = System.console().readPassword("\nPlease enter key passphrase for MySQL root: ")
      pass = new String(passRaw)
    }
    logger.info("User = "+user)
    logger.info("Pass = "+pass)

    if(user.size() <=0 || pass.size() <= 0) {
      throw new InvalidUserDataException("You must enter a root user identity and a password to proceed.")
    }

    project.ext.mysqlRootUserId = user
    project.ext.mysqlRootPassword = pass;

  } // end if has task
} // end whenReady

gradle.taskGraph.whenReady { taskGraph ->
  if(taskGraph.hasTask(':database:CreateWhedcappDatabaseAccessUser')) {

    def pass = ''
    def user = ''
    if(System.console() == null) {
      new SwingBuilder().edt {
        dialog(modal: true, // Otherwise the build will continue running before you closed the dialog
            title: 'Enter MySQL Whedcapp password', // Dialog title
            alwaysOnTop: true, // pretty much what the name says
            resizable: false, // Don't allow the user to resize the dialog
            locationRelativeTo: null, // Place dialog in center of the screen
            pack: true, // We need to pack the dialog (so it will take the size of it's children)
            show: true // Let's show it
        ) {
          vbox { // Put everything below each other
            label(text: "Please enter Whedcapp administrator Id:")
            input1 = textField()
            label(text: "Please enter key passphrase for Whedcapp:")
            input2 = passwordField()
            button(defaultButton: true, text: 'OK', actionPerformed: {
              user = input1.text;
              pass = input2.text; // Set pass variable to value of input field
              dispose(); // Close dialog
            })
          } // vbox end
        } // dialog end
      } // edt end
    } else {
      userRaw = System.console().read("\nPlease enter Whedcapp database user name:");
      user = new String(userRaw)
      passRaw = System.console().readPassword("\nPlease enter key passphrase for Whedcapp: ")
      pass = new String(passRaw)
    }
    logger.info("User 2 = "+user)
    logger.info("Pass 2 = "+pass)

    if(user.size() <=0 || pass.size() <= 0) {
      throw new InvalidUserDataException("You must enter a user identity or password to proceed.")
    }

    project.ext.mysqlWhedcappUserId = user;
    project.ext.mysqlWhedcappPassword = pass;

  } // end if has task
} // end whenReady

// Whedcapp administrator email:

gradle.taskGraph.whenReady { taskGraph ->
  if(taskGraph.hasTask(':database:CrudGenerationCfgPrep') ) {

    def user = ''
    if(System.console() == null) {
      new SwingBuilder().edt {
        dialog(modal: true, // Otherwise the build will continue running before you closed the dialog
            title: 'Enter Whedcapp administrator user identity', // Dialog title
            alwaysOnTop: true, // pretty much what the name says
            resizable: false, // Don't allow the user to resize the dialog
            locationRelativeTo: null, // Place dialog in center of the screen
            pack: true, // We need to pack the dialog (so it will take the size of it's children)
            show: true // Let's show it
        ) {
          vbox { // Put everything below each other
            label(text: "Please enter Whedcapp administrator user identity (email):")
            input = textField()
            button(defaultButton: true, text: 'OK', actionPerformed: {
              user = input.text; // Set pass variable to value of input field
              dispose(); // Close dialog
            })
          } // vbox end
        } // dialog end
      } // edt end
    } else {
      userRaw = System.console().readPassword("\nPlease enter Whedcapp administrator user identity (email): ")
      user = new String(userRaw)
    }

    if(user.size() <= 0) {
      throw new InvalidUserDataException("You must enter a Whedcapp administrator user identity (email) to proceed.")
    }

    project.ext.wcau = user;

  } // end if has task
} // end whenReady
